#!/usr/bin/env python
"""
Rudimentary Perl -> Python translation assistant.

Written 2011-09, by Steven J. DeRose.

2011-09-19ff sjd: Fixed:
    toasted indentation (expandTabs?
    break lines at ";" early on?
    how to get at $1 etc. after =~ s///?
    shift @foo to foo.shift()
    sys.stdout.isatty()
    -- is confused; only change after \w?
    spurious insertion of 1-os.path.getsize from ---s
    ? operator: create whole 'if' with newlines
    ditch 'new'
    ($x = $y) =~ ...
    XML tags in quotes turn into readline(tag)
    int goes to floor when it shouldn't (like in argparse)
    no type=string, action='store_true'
    for my $k (keys %foo) -> for k, v in foo ??
    spurious r""?
    class colon
    `...`
    newline at end of printed strings
    getopts version
    strip // from around regexes in split
    don't nuke % inside sprintf()
    Separate GetOpt conversion, so we can accumulate list of var names
    W/ GetOpt, deal with the prior inits.
    accumulate the options vars? use those vars later
    Handle shebang line at top, outside loop.
    Split and complile changes before main loop.
    (x]
    \$ \@ \%
    x[y]->[z]
    [@%]\{.*?\}
2011-10-17 sjd: tweaks
2012-01-10 sjd: +=, -=, *=, /=, .=, ->, (\s+, ; alone, preserve !=, ....
2012-01-12 sjd: Various regex tweaks for if, for, substr, =~, -->, ternary ?.
    Major upgrades to GetOpt() handling. Clean up mainline logic. "+" options.
2012-01-24 sjd: Major rewrite to handleGetOpt: Handle inverted options,
    set dest when needed, do aliases better, modularize.
2012-01-31 sjd: Minor tweaks. Add helpMessages. Fix list ops.
    Remove part-line comments early, then replace at end.
2014-04-25 Misc. clean-up. Code regexes as [ lhs, rhs ] instead of a string.
    Don't turn regex /g into flags="g" instead of nothing (or count=0)
2014-05-14: Better handling of @{$x}, for, while($x = readline()),...

(for "To do list", see POD at bottom)
"""

import sys, os, argparse, math, string, re, time, datetime

global recnum, args

__version__ = "2014-05-14"


###############################################################################
# Should rename any Perl variables with these names (not used yet)
#
reservedWords = [
    "and",      "assert",   "break",    "class",    "continue",
    "def",      "del",      "elif",     "else",     "except",
    "exec",     "finally",  "for",      "from",     "global",
    "if",       "import",   "in",       "is",       "lambda",
    "not",      "or",       "pass",     "print",    "raise",
    "return",   "try",      "while",

    "Data",     "Float",    "Int",      "Numeric",  "Oxphys",
    "array",    "close",    "float",    "int",      "input",
    "open",     "range",    "type",     "write",    "zeros",

    "acos",     "asin",     "atan",     "cos",      "e",
    "exp",      "fabs",     "floor",    "log",      "log10",
    "pi",       "sin",      "sqrt",     "tan"
    ]
reservedExpr = r'\$(' + '|'.join(reservedWords) + r')\b'


###############################################################################
# Default help messages to supply for common GetOptLong option names.
# Maybe: recursive, field, tickInterval, unicode, ascii,
#
global helpMessages
helpMessages = {
    "delim"          : 'Field separator.',
    "quote"          : 'Field quoting character.',
    "clean"          : "Recode control characters for readability.",
    "noclean"        : "Leave control characters as-is.",
    "color"          : "Colorize the output.",
    "nocolor"        : "Don't colorize the output.",
    "fields"         : "Names/numbers of fields to display (repeatable).",
    "files"          : "Path(s) to input data.",
    "iencoding"      : "Set the input character set (not yet).",
    "ilineends"      : "Style of line-ends to use (M|U|D)",
    "numberFields"   : "Show field numbers as well as field names.",
    "nonumberFields" : "Don't show field numbers as well as field names.",
    "pause"          : "Pause after each record (unfinished).",
    "nopause"        : "",
    "quiet"          : "Suppress most messages.",
    "noquiet"        : "",
    "verbose"        : "Add more messages (repeatable).",
    "width"          : "How many columns to leave for field labels.",
    #
    # For CSV package
    #
    "comment"        : "Ignore records beginning with this string.",
    "delim"          : "Field separator (default: tab).",
    "escape"         : "Character to escape quotes inside quotes.",
    "header"         : "There is a header record, providing field names",
    "noheader"       : "There is NO header record, providing field names",
    "nlInQuotes"     : "Allow newlines within quoted fields.",
    "nonlInQuotes"   : "Do not allow newlines within quoted fields.",
    "quote"          : "Character used to quote field values (default: '\"').",
    "qdouble"        : "Allow a quote inside quotes via '\"\"'.",
    "noqdouble"      : "Do not allow a quote inside quotes via '\"\"'.",
    "stripFields"    : "Remove leading/trailing whitespace from fields.",
    "nostripFields"  : "Do not remove leading/trailing whitespace from fields.",
    "stripRecords"   : "Remove leading/trailing whitespace from records.",
    "nostripRecords" : "Do not remove leading/trailing whitespace from records."
    }


###############################################################################
###############################################################################
# An ordered list of regex changes.
#
changes = [
    # Remove trailing spaces to simplify many later regexes
    [ r'\s+$/',                                     r''                     ],
    [ r'^(\s*)([^#]*?;)\s*([^\s#])',                r'\1\2;\n\1\3'          ], # ????

    ###########################################################################
    # Packages and inits
    #
    [ r'use strict.*',                              r'import sys, os, re, subprocess' +
        r'\nimport string\n' + r'import math\n'               ],
    [ r'use Getopt.Long',                           r'import argparse'      ],

    ###########################################################################
    # Regex match/change
    # (maybe also change simple cases to lstrip/rstrip)
    #
    [ r'^(\s*)\(\$(\w+) = \$(\w+)\) =~ s',         r'\1\2 = \3\n\1\1 =~ s'                     ],

    # =~ m// and !~ m// (and assign to 'mat' in case later code uses \1)
    #
    [ r'\$(\w+)\s*=~\s*m/^([^/]+)/g\b',            r"mat = re.match(r'\2', \1)"                ],
    [ r'\$(\w+)\s*=~\s*m/^([^/]+)/(\w+)',          r"mat = re.match(r'\2', \1, flags=\"\3\")"  ],
    [ r'\$(\w+)\s*=~\s*m/^([^/]+)/',               r"mat = re.match(r'\2', \1)"                ],

    [ r'\$(\w+)\s*=~\s*m/([^/]+)/g\b',             r"mat = re.search(r'\2', \1, count=0)"      ],
    [ r'\$(\w+)\s*=~\s*m/([^/]+)/(\w+)',           r"mat = re.search(r'\2', \1, flags=\"\3\")" ],
    [ r'\$(\w+)\s*=~\s*m/([^/]+)/',                r"mat = re.search(r'\2', \1)"               ],

    [ r'\$(\w+)\s*!~\s*m/([^/]+)/(\w+)',           r"not re.search(r'\2', \1, flags=\"\3\")"   ],
    [ r'\$(\w+)\s*!~\s*m/([^/]+)/',                r"not re.search(r'\2', \1)"                 ],

    # =~ s/// and remember that Perl changes the string in place...
    #
    [ r'\$(\w+)\s*=~\s*s/\^\\s+//',                 r'\1 = \1.lstrip()'                         ],
    [ r'\$(\w+)\s*=~\s*s/\\s+\$//',                 r'\1 = \1.rstrip()'                         ],
    [ r'\$(\w+)\s*=~\s*s/([^/]+)/([^/]+)/(.*)',     r'\1 = re.sub(r\'\2\', \3, \1, flags="\4")' ],
    [ r'\$(\w+)\s*=~\s*s/([^/]+)/([^/]+)/',         r'\1 = re.sub(r\'\2\', \3, \1)'             ],


    ###########################################################################
    # Flow of control
    #
    [ r'^(\s*)if \((\s*my\s+)?\$(\w+)\s*=\s*(.*)\)\s*{',
                                                    r'\1\3 = \4\n\1if (\3):'    ],
    # if
    #
    [ r'(\bif\s*\([^\)]*\))\s*{',                   r'\1:'                      ],
    [ r'^(\s*)if\s*(\([^{}]*\))\s*{(\s*\S+)?\s*$',  r'\1if \2:\n\1    \3'       ],
    [ r'\belsif\s*(\S.*)\s*{',                      r'elif \1:'                 ],
    [ r'\belse\s*{',                                r'else:'                    ],
    [ r'^(\s*)(.*)\bunless\s*(\(.*?\));',           r'\1if (not \3):\n\1 \2'    ],
    [ r'^(\s*)(\S.+?) unless (\(.*\));',            r'\1if (not \3):\n\1    \2' ],
    [ r'^(\s*)(\S.+?) if (\(.*\));',                r'\1if (\3):\n\1    \2'     ],

    # for
    #
    [ r'\bfor\s*\((my\s+)?\$(\w+)\s*=\s*([^;]*);' +
      r'\s*\$\w+\s*<=?\s*([^;]*);' +
      r'\s*\$\w+\s*(\+\+|\+=\s*1)\)\s*{',
                                                    r'for \2 in range([\3,\4]):' ],
    [ r'\bfor\s*\((my\s+)?\$(\w+)=(\d+);\s*\$\2\s*<=\s*(.*?);\s*\$\2\+\+\) {',
                                                r'for \2 in (range(\3,\4+1)):'  ],
    [ r'\bfor (my )?(\S+) \(keys (.*)\) {',         r'for \2 in (\3):'          ],
    [ r'\bfor (my )?(\S+) \((.*)\) {',              r'for \2 in (\3):'          ],
    [ r'\bforeach\s*(my\s+)?(\w+)\s*\(.*?\)',       r'for \2 in (\3)'           ],

    # other flow of control
    #
    [ r'\bwhile (\([^{]+\)) {',                     r'while (\1):'              ],
    [ r'\bnext\b',                                  r'continue'                 ],
    [ r'\blast\b',                                  r'break'                    ],
    [ r'\bexit\b',                                  r'sys.exit'                 ],

    # Short-cut AND and OR
    #
    [ r'^(\s*)(\(.*?\)) &&\s*',                     r'\1if \2:\n\1    '         ],
    [ r'^(\s*)(\(.*?\)) \|\|\s*',                   r'\1if (not \2):\n\1    '   ],

    # Ternary ?... (not really right...).
    #
    [ r'^(\s*)(my\s+)([$@%]\w+)\s*=\s*(\(.*?\))\s*\?(.*)\s*:\s*(.*);',
                        r'\1if \4:\n\1    \3 = \5\n\1else:\n\1    \3 = \6'      ],
    [ r'\^(\s*)\((.*?)\) \|\| ',                    r'\1if (not \2):\n\1     '  ],


    ###########################################################################
    # Functions
    #
    [ r'\bsort keys ([$\w+]+|%{[$\w+]+})',          r'sorted(\1, key=\1.get)'   ],
    [ r'\bsort\b',                                  r'sorted'           ],

    [ r'\bint\(\b',                                 r'floor('           ],
    [ r'\bdelete\b',                                r'del'              ],
    [ r'\bundef\b',                                 r'None'             ],

    #[ r'\bpackage (.*);',                          r'class \1:'        ],
    [ r'\bbless\b',                                 r'# bless'          ],
    [ r'\bdefined\b',                               r'None == '         ],
    [ r'= new ',                                    r'= '               ],
    [ r'sub new ',                                  r'  def __init__()' ],
    [ r'sub (\w+::)+(\w+) ',                        r'  def \2'         ],

    [ r'\blc\s*\(',                                 r' lower('          ],
    [ r'\buc\s*\(',                                 r' upper('          ],
    [ r'\blength\b\(',                              r'len\('            ],
    [ r'\bjoin\(("[^"]"),\s*',                      r'\1.join('         ],
    [ r'\bjoin\((\'[^\']\'),\s*',                   r'\1.join('         ],
    [ r'\bchomp\s+([\$\w]+)',                       r'\1 = strip(\1,"\n\r")' ], # ???
    [ r'\bsplit\(/(.*)/',                           r' re.split(\'\1\'' ],
    [ r'\bsubstr\(([^,]*?),([^,\)]*)\)',            r' \1[\2:]'         ], # ???
    [ r'\bsubstr\(([^,]*?),([^,]+?),([^,]*?)\)',
                                                    r' \1[\2:\2+\3]'    ],
    [ r'\breverse\s*\(\$(\w+)\)',                   r' \1[::-1]'        ],
    [ r'^(.*)\btranslate\s*\((.*?),(.*?),(.*?)\)',
            r'\1mytrans = maketrans(\3,\4)\n\1translate(\2,mytrans)'    ],
    [ r'\bhex\s*\(',                                r' fromhex('        ],
    [ r'\btime\s*\(',                               r' gmtime('         ],

    [ r'\bopen\s*\(?(\w+),\s*>(.*?)\)?',            r'\1 = open(\2,"w");' ],
    [ r'\bopen\s*\(?(\w+),\s*<(.*?)\)?',            r'\1 = open(\2,"r");' ],
    [ r'\bclose\s*\(?(\w+)\)?',                     r'\1.close()'       ],

    [ r'\bsprintf\(("[^"]),\s*',                    r'\1 % ('           ],
    [ r'\bprintf\(("[^"]),\s*',                     r'print(\1 % ('     ],

    # Stack functions
    #
    [ r'\bpop @(\w+)\b',                            r'\1.pop()'         ],
    [ r'\bpush @(\w+)\s*,\s*(.+?)(\b|$|;)',         r'\1.append(\2)'    ],
    [ r'\bshift @(\w+)\b',                          r'\1.pop(0)'        ],
    [ r'\bunshift @(\w+),\s*(.+?)\b',               r'\1.insert(0,\2)'  ],

    [ r'\bpop @{$(\w+)}\b',                         r'\1.pop'           ],
    [ r'\bpush @{$(\w+)}\s*,\s*(.+?)(\b|$|;)',      r'\1.append(\2)'    ],
    [ r'\bshift @{$(\w+)}\b',                       r'\1.pop(0)'        ],
    [ r'\bunshift @{$(\w+)},\s*(.+?)\b',            r'\1.insert(0,\2)'  ],

    ###########################################################################
    # Variable and subroutine definitions
    # (multi-line array/hash assignments don't have their () fixed)
    # Should discard 'my' etc. earlier??
    #
    [ r'^sub (.*)\s*{',                             r'def \1('          ],
    [ r'^(\s*)(my|local|our)\s+\$(\w+);',           r'\1\2 = None'      ],
    [ r'^(\s*)(my|local|our)\s+\@(\w+\s*)=\s*();',  r'\1\2 = []'        ],
    [ r'^(\s*)(my|local|our)\s+\%(\w+\s*)=\s*();',  r'\1\2 = {}'        ],
    [ r'^(\s*)my \(\s*(.*)\)\s*=\s*@_;',            r'\1\2):'           ],
    [ r'^\s*(my|local|our)\s+@(.*?)\s*=\((.*)\)$',  r'\1 = array([\2])' ],
    [ r'^\s*(my|local|our)\s+@(.*?)\s*=\((.*)$',    r'\1 = array([\2'   ],
    [ r'^\s*(my|local|our)\s+%(.*?)\s*=\((.*)\)$',  r'\1 = {\2\}'       ],
    [ r'^\s*(my|local|our)\s+%(.*?)\s*=\((.*)$',    r'\1 = {\2'         ],
    [ r'\b(my|local|our)\s+[@%\$]',                 r''                 ],


    ###########################################################################
    # Reserved variables, system stuff, etc.
    #     Special variable are not done yet. See Perldoc at end.
    #
    [ r'\$ENV\{(.*?)\}',                        r'os.environ["\1"]'     ],
    [ r'\b[$@]ARGV',                            r'sys.argv'             ],
    [ r'\$_ ',                                  r'$dftVar '             ],
    [ r'\$(\d)\b',                              r'mat.group(\1)'        ],
    [ r'= `(\w+) (.*)`',            r'= exec_command(["\1", "\2"])'     ],

    [ r'\bscalar[ \(]+',                        r'len('                 ],
    [ r'\bprint[ (](.*?)\\n"\)?;',              r'print(\1")'           ],
    [ r'\bprint[ (](.*?)\)?;',                  r'print(\1)'            ],

    # I tend to start a new line after 'die' and 'warn' keywords,
    # so insert the "(". Still have to insert the ")" manually.
    #
    [ r'\b(die|warn|print)\s*$',                r'\1('                  ],

    # See also under handling of quoted lines....
    #
    [ r'^(\s*)\bdie\b(.*);',        r'\1print(\2) # DIE\n\1    exit(0)' ],
    [ r'\bwarn\s*\(?(.*)\)?\s*;',               r'sys.stderr.write(\1)' ],
    [ r'\bwarn\s*$',                            r'sys.stderr.write('    ],

    [ r'\$self->\{([^{}]+)\}',                  r'self.\1'              ],
    [ r'->',                                    r'.'                    ],
    [ r'\$(\w+)(\.)?\{([^{}]+)\}',              r'\1[\3]'               ],

    ###########################################################################
    # File operations
    #    (happens *after* stripping variable prefix chars [$@%])
    #
    [ r'\b-r\s+\$?([^()]+)',                    r'os.access(\1,os.R_OK)'    ],
    [ r'\b-w\s+\$?([^()]+)',                    r'os.access(\1,os.W_OK)'    ],
    [ r'\b-x\s+\$?([^()]+)',                    r'os.access(\1,os.X_OK)'    ],
    [ r'\b-e\s+\$?([^()]+)',                    r'os.path.exists(\1)'       ],
    [ r'\b-z\s+\$?([^()]+)',                    r'os.path.getsize(\1)>0'    ],
    [ r'\b-s\s+\$?([^()]+)',                    r'os.path.getsize(\1)'      ],
    [ r'\b-d\s+\$?([^()]+)',                    r'os.path.isdir(\1)'        ],
    [ r'\b-f\s+\$?([^()]+)',                    r'os.path.isfile(\1)'       ],
    [ r'\b-t\s+\$?([^()]+)',                    r'\1.isatty()'              ],

    [ r'\bSTDIN\b',                             r'sys.stdin'                ],
    [ r'\bSTDOUT\b',                            r'sys.stdout'               ],
    [ r'\bSTDERR\b',                            r'sys.stderr'               ],

    # <...> for reading input file
    # Would be nice to pull this out when it's in an '[el]if'...
    [ r'^(\s+)while\s*\((\w+)\s*=\s*<(\$?\w+)>\)?\s*{',
        r'\1while(1):\n    \1\2 = \3.readline()\n    \1if (not \1): break'  ],
    [ r'\s*=\s*<(\$\w+|[A-Z]+)>',               r'= \1.readline()'          ],


    ###########################################################################
    # Operators
    #
    # r'\s*%(\s+|$)',                           r'mod '       ], ###
    [ r'=>',                                    r':'          ],
    [ r'\s*\{(\s*#.*)$',                        r':\1'        ], # { # comment
    [ r'\s*\{\s*$',                             r':'          ], # {
    [ r'\s*\}(\s*#.*)$',                        r'\1'         ], # } # comment
    [ r'\s*\}\s*$',                             r''           ], # }
    [ r'\s+&&(\s+|$)',                          r' and '      ], # &&
    [ r'(^|\s+)\|\|(\s+|$)',                    r' or '       ], # ||
    [ r'\.\.',                                  r':'          ], # range
    [ r'::',                                    r'.'          ], # package-sep
    [ r'"\s+\.\s+\$',                           r'" + '       ], # concat
    [ r'(\w)\s+\.\s+(["$])',                    r'"\1 + \2'   ], #
    [ r'\+\+',                                  r' += 1'      ], # ++
    [ r'([a-zA-Z])\-\-([^>])',                  r'\1 -= 1\2'  ], # -- (not -->)
    # r'\b(\S)\s*([-+*/])=',                    r'\1 = \1 \2' ], ### += -= *= /=
    [ r' \.=(\s+|$)',                           r' += '       ], # .= (concat)
    [ r' \.(\s+|$)',                            r' + '        ], # . (concat)
    [ r'" x ',                                  r' " * '      ], # "foo" x 7
    [ r'(\$\w+) x ',                            r' "\1 * '    ], # $var x 3
    [ r'%\$|@\$',                               r''           ], # cast-from-ref
    [ r'\\[$@%]',                               r''           ], # cast-to-ref
    [ R'\]->\[',                                r']['         ],

    # Operators: comparison
    #
    [ r'(\S+)\s+<=>\s+(\S+)',                   r' cmp(\1,\2)'  ],
    [ r'(\S+)\s+cmp\s+(\S+)',                   r' cmp(\1,\2)'  ],
    [ r' lt ',                                  r' < '          ],
    [ r' le ',                                  r' <= '         ],
    [ r' gt ',                                  r' > '          ],
    [ r' ge ',                                  r' >= '         ],
    [ r' eq ',                                  r' == '         ],
    [ r' ne ',                                  r' != '         ],

    [ r'([( ])!([^=~])',                        r' \1not \2'    ],


    ###########################################################################
    # Weird cleanup -- these were added to clean up problems discovered.
    # Deleting some of them would be nice.
    #
    [ r'(\("[^"]*\')[$@%](\w+)(\'[^"]*")',    r'\1" + \2 + "\3' ],
    [ r';\s*}:\s*$',                            r''             ], # ???
    [ r'^(\s*)(if\s*\(.*\))\s*{\s*(}\s*)$',     r'\1\2:'        ], # if ()
    [ r'^(\s*)(if\b.*:)\s*(\S)',             r'\1\2:\n\1    \3' ],
    [ r'@\{(.*?)\}',                            r'\1'           ],
    [ r'@\[(.*?)\]',                            r'\1'           ],
    [ r'[$@%]([A-Za-z]+)',                      r'\1'           ], # var names
    # r';\s*(#.*)$',                            r' \1'          ], ###
    # r'([^#\s])\s\s+',                         r'\1 '          ], ###
    [ r'\)\s+:\s*$',                            r'):'           ],
    # r'[\(\[\{]\s+',                           r'('            ], ###
    [ r'\.\[',                                  r'['            ],
    # r'\.\{',                                  r'['            ], ###
    [ r'^(\s*def .*)\s*\(\s+',                  r'\1('          ],
    [ r'\s*;\s*$',                              r''             ], # leftover ";"
    [ r'^\s*;\s*',                              r''             ],

    # Even up margins to multiple of 4
    #
    [ r'(\S)  +=',                              r'\1 ='         ],
    [ r'^ (\S)',                                r'\1'           ],
    [ r'^     (\S)',                            r'    \1'       ],
    [ r'^         (\S)',                        r'        \1'   ],
    [ r'\(\s+',                                 r'('            ],
    [ r'\bif  +',                               r'if '          ],
    [ r'\bnot  +',                              r'not '         ],


    ] # END OF CHANGE LIST


###############################################################################
# Not used yet
#
specialVarChanges = [
    [ r'$|\b',     r'#FIX \\1#' ], # If set to nonzero, forces flushes
    [ r'$%\b',     r'#FIX \\1#' ], # Current page number
    [ r'$=\b',     r'#FIX \\1#' ], # Current page length
    [ r'$-\b',     r'#FIX \\1#' ], # Number of lines left on the page
    [ r'$~\b',     r'#FIX \\1#' ], # Name of the current report format
    [ r'$^\b',     r'#FIX \\1#' ], # Name of the current top-of-page format

    # [ r'$\d\b',  r'#FIX \\1#' ], # Subpattern from last match. I<Renamed to C<mat.group(n)>
    [ r'$&\b',     r'#FIX \\1#' ], # String matched by the last pattern match
    [ r'$`\b',     r'#FIX \\1#' ], # String preceding whatever was matched
    [ r"$'\b",     r'#FIX \\1#' ], # String following whatever was matched
    [ r'$+\b',     r'#FIX \\1#' ], # Last bracket matched by last pattern

    [ r'$_\b',     r'#FIX \\1#' ], # Default input and pattern space. I<Renamed to dftVar>
    [ r'$.\b',     r'#FIX \\1#' ], # Current line number of the last filehandle read
    [ r'$/\b',     r'#FIX \\1#' ], # Input record separator
    [ r'$\\b',     r'#FIX \\1#' ], # Output record separator for print
    [ r'$,\b',     r'#FIX \\1#' ], # Output field separator for print
    [ r'$"\b',     r'#FIX \\1#' ], # Similar to $, except for array values in a "string"
    [ r'$#\b',     r'#FIX \\1#' ], # Output format for numbers via print.
    [ r'$$\b',     r'#FIX \\1#' ], # Process number of the Perl running this script
    [ r'$?\b',     r'#FIX \\1#' ], # Status of last pipe close, backtick(``) or system.
    [ r'$*\b',     r'#FIX \\1#' ], # 1 for multi-line matching within a string
    [ r'$0\b',     r'#FIX \\1#' ], # Name of the Perl script being executed
    [ r'$[\b',     r'#FIX \\1#' ], # Index of first element in array; character in string
    [ r'$]\b',     r'#FIX \\1#' ], # First part of perl -v
    [ r'$;\b',     r'#FIX \\1#' ], # Subscript separator for array emulation.
    [ r'$!\b',     r'#FIX \\1#' ], # In numeric context, current value of errno
    [ r'$@\b',     r'#FIX \\1#' ], # Error message from last eval, do-FILE, or require
]


###############################################################################
###############################################################################
# Expand variable references inside a Perl double-quoted string
# (may come in with ';' and/or comment at end)
# (perhaps should also drop a final "\\n"?)
#
# ### See replacement following....
#
def varsInString(s):
    # Strip comment if any (breaks for '#' inside quotes)
    com = ""
    comloc = s.find('#')
    if (comloc>=0):
        com = s[comloc:]
        if (com[0:1] != "#"):
            print("## Bad comment: " + s)
        s = s[0:comloc]
    s = re.sub(r'\s+$',"",s)
    semi = 0
    if (s[-1:] == ";"):
        semi = 1
        s = s[0:-1]

    parts = re.split(r'(".*?")',s)
    buf = ""
    for x in parts:
        if (x == ""):
            continue
        if (x[0] == '"'):
            #print "    q: " + x
            x = re.sub(r'\$(\w+)\{(.*?)\}',   r'" + str(\1[\2]) + "', x)
            x = re.sub(r'\$(\w+)\[(.*?)\]',   r'" + str(\1[\2]) + "', x)
            x = re.sub(r'\$(\w+)',            r'" + str(\1) + "'    , x)
        buf = buf + x

    buf = re.sub(r'\\n"$', "\"",buf)
    if (semi):
        buf = buf + ")"
    buf = buf.rstrip() + " " + com + "\n"
    return(buf)


###############################################################################
"""Extract variables from inside quotes, and handle Perl's many quote types.

 ==> Move to top level so only unquoted stuff goes to the regexes. Requires
 separately collecting stuff outside of quotes, and passing that through with
 some substitutes for the quotes bits inserted then replaced.

 (see http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators)

 Customary Generic       Meaning           Interpolates
 --------- -------       -------           ------------
       ''   q{}          Literal           no
       ""  qq{}          Literal           yes
       ``  qx{}          Command           yes*
           qw{}          Word list         no
       //   m{}          Pattern match     yes*
           qr{}          Pattern           yes*
            s{}{}        Substitution      yes*
           tr{}{}        Transliteration   no (but see below)
            y{}{}        Transliteration   no (but see below)
          <<EOF          here-doc          yes*

   * unless the delimiter is ''.

 To do:
     insert first/last qw quotes
     insert system call for back-quotes
     handle s/tr/y 2nd argument (must 1st and 2nd use same delim?

"""
def varsInString2(s):
    buf = ""              # Build up the result here
    pos = 0               # Current offset in source string
    inQuote = ""          # What kind of Perl quote are we in ("" = none)
    outQuote = ""         # String we expect in Perl, to end the quote
    delim = ""            # What char after inQuote, as delimiter?
    interpolate = 0       # Are variables recognized in this kind of quote?
    toMakeClose = ""      # What to issue for Python at close of quote

    indent = re.sub(r'\S.*$',"",s) # Leading whitespace in case of new '\n'

    while (pos < len(s)):
        c = s[pos]

        if (inQuote == ""):                 # OUTSIDE QUOTES
            if (c == "#"):                                  # comment!
                buf += s[pos:]
                pos = len(s)
                toMakeClose = c
                continue
            if (c == '"'):                                  # start double
                buf += c
                inQuote = c
                interpolate = 1
                outQuote = c
                toMakeClose = c
                continue
            if (c == "'"):                                  # start single
                buf += c
                inQuote = c
                interpolate = 0
                outQuote = c
                toMakeClose = c
                continue
            if (c == "`"):                                  # start back
                buf += 'exec_command("""',
                inQuote = c
                interpolate = 1
                outQuote = c
                toMakeClose = '""")'
                continue
            if (c == ";"):
                buf += "\n" + indent
                continue
            if (c == "<" and re.match(r'<<EOF',s[pos:])):   # start 'here'
                buf += '"""'
                pos += 4
                inQuote = "<<EOF"
                interpolate = 1
                outQuote = "EOF"
                toMakeClose = '"""'
                continue
            mat = re.match(r'(q|qq|qx|qw|m|qr|s|tr|y)(#|\s*[\W)',pos) # others
            if (mat):
                inQuote = mat.group(1)
                interpolate = 0
                if (re.match("qq|qx|m|qr|s",mat.group(1))):
                    interpolate = 1
                twoArgs = 0
                if (re.match("s|tr|y",mat.group(1))):
                    twoArgs = 1
                pos += len(inQuote)
                delim = mat.group(2)
                delim = re.sub(r'^\s+',"",delim)
                if (delim == '('):
                    delim = ')'
                elif (delim == '['):
                    delim = ']'
                elif (delim == '{'):
                    delim = '}'
                elif (delim == "'"):
                    interpolate = 0
                outQuote = delim
                buf += '"""'
                toMakeClose = '"""'
                continue
            buf += c                                        # just copy

        else:                               # INSIDE QUOTES
            if (c == '\\'):                                 # \-char
                pos += 1
                buf += c + s[pos]
                continue
            if (re.match(outQuote,s[pos:])):                # close quote
                buf += toMakeClose
                toMakeClose = ""
                inQuote = ""
                continue
            if (interpolate and c in [ '$', '@' ]):         # variable
                mat = re.match(r'.\w+',s[pos:])
                if (mat.group):
                    buf += outQuote + ' + str(' + mat.group + ') + ' + inQuote
                    pos = mat.end
                else:
                    buf += '"\n## PROBLEM: syntax within quote\n"'
                continue
            if (inQuote == "qw"):                           # quote words
                mat = re.match(r'\s+', s[pos:])
                if (mat):
                    buf += '", "'
                    pos += len(mat.group)
                else:
                      buf += c
                continue
            buf += c                                        # just copy

        pos += 1                            # ALWAYS INCREMENT
    # while some s left
    return(buf)



###############################################################################
###############################################################################
"""Handle GetOpt::Long (option parser) package. It is separate because it:
 * takes several regexes out of an already-long list
 * doesn't collide with similar code elsewhere
 * accumulates option variable names so we can update them later
 # does some fancy parsing for option types, repetition flags, etc.

 To do:
     write out sub and convert_bases definitions

 Python argparse add_argument() notes:
     1 or more args for name(s): "-f", "file", "in"
     action='store'|'store_const'|'store_true'|'store_false'|'append'|
         'append_const'|'count'|'help'|'version' or impl of argparse.Action
         const=value (used for store_const, or for option w/o arg nargs='?'
     nargs=int|'?'|'*'|'+'|argparse.REMAINDER
     dest="dictKey" (defaults reasonably)
     type={bool|int|float|complex|str|open|argparse.FileType('w')}
         (or can name a fn that returns a converted value or raises exc)
     choices=range(0,10) | "UMD" | ("U", "M", "D")
     required=True
     help="some doc on the option"
     default="something"|argparse.SUPPRESS
     metavar='xxx' to get different print name in help
 Can also do mutually-exclusive groups.
"""
def oneArg(n, v, quote=True):
    if (not v):
        return("")
    if (quote):
        return((n+'="'+v+'",').ljust(24))
    else:
        return((n+'='+v+',').ljust(24))

def niceText(names, dest=None, nargs=None, action=None, type=None):
    global args, helpMessages

    theOpt = 'parser.add_argument(\n'

    # Separate any "|" aliases
    for i in (range(len(names))):
        n = names[i]
        if (len(n) == 1 or args.singleQuoteOptions):
            theOpt += '"-' + n + '", '
        else:
            theOpt += '"--' + n + '", '

    # Add any options
    theOpt += '\n    '
    theOpt += oneArg('type', type, quote=False)
    if (dest != names[0]):
        theOpt += oneArg('dest', dest)
    theOpt += oneArg('action', action)
    theOpt += oneArg('nargs', nargs)
    helpMsg = ""
    if (names[0] in helpMessages): helpMsg = helpMessages[names[0]]
    theOpt += '\n    help="' + helpMsg + '")\n'

    return(theOpt)


"""Sort out just what argparse options we need, based on GetOpt flags.
 Let niceText() above, do the layout from that.
"""
def makeOneOption(nameList, suffix, varType, varName, append):
    buf = ""
    # Only specify dest, if the Perl varName not same as option name.
    dest = None
    if (varName and varName != nameList): dest = varName
    action = ""
    if (append == True):
        action = "append"

    names = re.split(r'\|', nameList)
    if   (suffix == ""):                      # flag
        if (not action): action = 'store_true'
        buf = niceText(names, dest=dest, action=action)
    elif (suffix == "+"):                     # increment
        buf = niceText(names, dest=dest, action='count')
    elif (suffix == "=s"):                    # string
        buf = niceText(names, dest=dest, action=action, type='str')
    elif (suffix == "=n" or suffix == "=i"):  # int
        buf = niceText(names, dest=dest, action=action, type='int')
    elif (suffix == "=f"):                    # float
        buf = niceText(names, dest=dest, action=action, type='float')
    elif (suffix == "=o"):                    # int 077 0xff 0b11
        if (not action): action = 'convert_bases'
        buf = niceText(names, dest=dest, action=action)
    elif (suffix == "!"):                     # invertible
        actionT = action
        actionF = action
        if (not action):
            actionT = 'store_true'
            actionF = 'store_false'
        buf = niceText(names, action=actionT, dest=names[0])
        negatedNames = []
        for n in (names):
            negatedNames.append('no'+n)
        buf += niceText(negatedNames, dest=dest, action=actionF)
    else:
        buf += "### PROBLEM: Unknown GetOpt option suffix '" + suffix + "'\n"
        # such as =s@ =n% =f{3,5}
    return(buf)


"""Provide fixed text to go at the end of the option dcls.
"""
def addBoilerPlate():
    bp = ""
    bp += ('parser.add_argument("files",\n' +
           '    type=argparse.FileType("w"), nargs=argparse.REMAINDER,\n' +
           '    help="Path(s) to input data.")\n')
    bp += "global args\n"
    bp += "\nargs = parser.parse_args()\n"
    bp += "\n"
    return(bp)


"""Parse the actual Getopt::Long call and convert to Python.
"""
def handleGetOpt(ifh):
    optionsResult = """
        parser = argparse.ArgumentParser(
            version="Version of  " + __version__,
            description="")
        """
    lastLineBad = 0

    global recnum, args
    while (True):
        rec = ifh.readline()
        if (not rec):                                  # EOF
            print("## PROBLEM: EOF found in middle of GetOpt")
            break
        recnum = recnum + 1

        if (re.match(r'\s*\)\s*;',rec)):               # end of GetOpt()
            break
        if (re.match(r'^\s*#',rec)):                   # comment
            print(rec)
            continue
        if (re.match(r'^\s*$',rec)):                   # blank line
            print(rec)
            continue

        # Special case reserved options
        if (re.match(r'\s*"version"\s+=>',rec)):            # -version
            continue
        if (re.match(r'\s*"(h\|)?help[^"]*"\s+=>',rec)):    # -help
            continue

        # If we get here it should be a real option, so parse & convert
        #
        mat = re.match(
            r'\s*"([|\w]*)(!|=[nsof]|\+)?"(\s+)=>\s*(\\[@$%]\w+,|sub\s*.*)$',
            rec)
        if (not mat):
            if (not lastLineBad): # don't issue lots of messages in a row
                print("## PROBLEM in GetOpt (line #" + str(recnum) + "):")
                lastLineBad = 1
            print "##" + rec,
            continue

        lastLineBad = 0
        optName = mat.group(1)
        optSuff = mat.group(2)
        alignSp = mat.group(3)
        rhs     = mat.group(4)
        varType = rhs[0:2]
        varName = rhs[2:-1]
        append  = False

        if (varType == "\\$"):
            pass
        elif (varType == "\\@"):
            append = True
        elif (varType == "\\%"):
            print("## PROBLEM: % targets not yet supported")
        elif (re.match(r'sub\s+{', rhs)):
            print("## PROBLEM: sub{} target for '" + optName + "': " + rhs)
            varName = ""
        else:
            print("## PROBLEM: unknown rhs for '" + optName + "': " + rhs)
            varName = ""

        # Put together the option declarations
        #
        optionsResult += makeOneOption(
            optName,optSuff,varType,varName,append)
    # until end of GetOpt() call

    optionsResult += addBoilerPlate()
    print(optionsResult)
# handleGetOpt



###############################################################################
###############################################################################
"""Parse command-line options to this conversion script
"""
parser = argparse.ArgumentParser(
    version="Version of " + __version__,
    description="""
Partially convert a Perl program to Python. This doesn't really understand
anything; it mainly does an awful lot of regex changes. But that fixes
countless keyword differences, operators, functions, curly braces,
variables in "strings", simple uses of regexes, etc. It also know about
Getopt::Long, and does a pretty good job of converting to Pythons argparse.
Of course, Perl has many ways of doing things, and this script does not catch
nearly all of them, and it gets a few things wrong.
But I find it saves a lot of time.
A utility by Steven J. DeRose.
    """,
    epilog="(see also 'perldoc "+sys.argv[0]+"')"
    )
parser.add_argument('-getOptVar', type=str,
    help='Assume this variable is where getOptLong arguments are built.')
parser.add_argument('-singleQuoteOptions', action="store_true",
    help='Prefix "-" instead of "--" for long option names.')
parser.add_argument('-tabs', type=int, default=4,
    help='Assume tab stops this far apart.')
parser.add_argument('-trace', action="store_true",
    help='Display regexes while compiling and running.')
parser.add_argument('-verbose', action="count",
    help='Provide more tracing information.')
parser.add_argument('files',
    type=argparse.FileType("r"), nargs=argparse.REMAINDER,
    help='Path to a Perl file to (partly) convert to Python.')

global args
args = parser.parse_args()
#args = vars(args)

recnum      = 0   # What line number are we at?
inpod       = 0   # State: inside a Perldoc pod...cut block?
seenPackage = 0   # Has there been a 'package' line yet?

ifh = args.files[0]
if (not ifh):
    su.die("Can't open input file '" + args.files[0] + "'")
print("file: '"+`ifh`+"'")

# Compile the regexes.
#
expected = 157
nChanges = len(changes)
if (nChanges != expected):
    sys.stderr.write(
        "Expected %d changes, but found %d; did you mean to change that?\n" %
        (expected, nChanges))

nc = 0
for ch in changes:
    nc = nc + 1
    if (len(ch) != 2):
        print("Bad regex change #%d: ###%s###" % (nc, "###".join(ch)))
        sys.exit(0)
    try:
        ch.append(re.compile(ch[0]))
    except:
        print("## Can't compile regex #%d: LHS: /%s/" % (nc, ch[0]))
        sys.exit(1)


###############################################################################
"""Read the Perl code and apply the regexes to each line (handle comments,
    perldoc pod...cut blocks, whole-line strings, package,
    and GetOpt() calls specially).
"""
rec = ifh.readline()
recnum = recnum + 1
while(rec):
    recnum += 1
    if (args.verbose): print("#"+`recnum`+": "+rec)
    rec = re.sub(r'\n','',rec)
    if (args.verbose): print "\n*** [" + recnum + "]: '" + rec

    if (inpod > 0):                                    # in perldoc
        print rec
        if (re.match('=cut',rec)):
            print '""" # End of pod'
            inpod = 0

    elif (re.match('=' + 'pod',rec)):                  # start perldoc
        print 'pod = """'
        print ''
        print rec
        inpod = 1

    elif (re.match('(my\s+)?\$\w+\s*=\s*GetOptions\s*\(',rec)): # GetOpt::Long
        handleGetOpt(ifh)

    elif (args.getOptVar and
          re.match('\s*(my\s+)?[$%]\s*=',rec)):       # Args for GetOpt::Long
        handleGetOpt(ifh)

    elif (re.match('\s*"[^"]*";?\s*(#.*)?$',rec)):    # lone "string"
        print varsInString(rec)

    elif (re.match('\s*#!',rec)):                     # shebang
        print '#!/usr/bin/python'
        #print ('# ' + str(time.localtime()) +
        print ('# ' + str(datetime.date.fromtimestamp(time.time())) +
               ': Converted by perl2python, by Steven J. DeRose.')

    elif (re.match('\s*#',rec)):                      # comments
        print rec

    elif (re.match('package ',rec)):                  # indent 'def'?
        print(re.sub(r'package', 'class', rec))
        seenPackage = 1

    else:
        rec = rec.expandtabs(args.tabs)               # normalize tabs

        com = ""                                      # Strip trailing comment
        mat = re.search(r'\s*#[^"]*$',rec)
        if (mat):
            com = rec[mat.start():]
            rec = rec[0:mat.start()]

        for i in range(nChanges):                     # do the changes
            if (args.trace):
                print('    ' + str(i) + ': |' + changes[i][2].pattern +
                      '|' + changes[i][1] + '|')
            try:
                rec2 = re.sub(changes[i][2], changes[i][1], rec)
            except Exception as X:
                if (str(X) != "unmatched group"):
                    print("#### Exception at line " + str(recnum) + "\n" +
                          "    " + rec + "\n" |
                          "    lhs: " + changes[i][0] + "\n" |
                          "    rhs: " + changes[i][1] + "\n" |
                          "    Exception is: " + str(X))
                    exit
            if (rec != rec2):
                rec = rec2
        if (com):
            rec = rec.rstrip() + " " + com
        if (re.match('(  )?def',rec)):                # join up with arg dcl
            print rec,
        elif (rec != "\s*;\s*\n"):
            print rec
    # endif
    rec = ifh.readline()
    recnum = recnum + 1

ifh.close()

exit(0)



###############################################################################
###############################################################################
#
perldoc = """

=pod

=head1 Usage

perl2python [options] file

A rudimentary C<Perl> to I<Python> translation assistant.

This script does not do a complete translation, but does handle many of
the tedious, repetitive, simple parts. Run some Perl code through
it, and then finish the translation by hand. You'll still have a lot of
small changes to make, but you won't have to remove thousands of semicolons,
change C<{> to I<:>, take C<$@%> off of variables
(leaving C<sprintf("...%..."...)> intact),
rename functions (C<lc>() to I<lower>(), etc.).

B<Note>: This mainly applies a long list of regex changes, line by line.

B<Note>: A few errors that can be caught, will be reported inline with
comments starting C<## PROBLEM>.


=head2 Some things this script will do (mostly)

=over

=item * Change the shebang (C<#!>) line.

=item * Put in I<import> lines for common packages.

=item * Convert loops and conditions:
  if/elsif/else
  postfix C<if> and C<unless>;
  C<(expr) ? y:z>;
  C<(expr) && action>;
  C<next> to I<continue>;
  C<last> to I<break>;
  C<for (my x=y; x<z; z++)> and similar simple cases
  and so on.

=item * Fix most C<{}>, etc.

=item * Discard C<my/our/local>, and the type-characters on variables.

=item * Rearrange C<=~> and C<!~> into Python I<re> package forms.
Even change them to lstrip() and rstrip() when appropriate.

=item * Change regex matches to save the Python match object as I<mat>,
add $1 etc. to mat.group(1) etc. These will sometimes need manual cleanup.

=item * Change $_ to $dftVar (more will typically be needed since I<$_>
is set automatically, and that doesn't translate easily).

=item * Convert C<Getopt::Long> to Python's I<argparse>.
However, there are some limitations, including:

=over

=item * one argument definition per line (synonyms are handled, though).

=item * If you create a hash of the argument definitions as a separate variable,
instead of just passing them all as arguments to C<getOpt::Long()>, then you
must specify the variabe name on the I<--getOptVar> option to this script.

=item * Anonymous C<sub>s for the action part don't work.

=item * Entries for I<--help> and/or I<--version> will be deleted, since
Python gives you those for free.

=item * Won't copy option-variable declarations from earlier (for
defaults), into the I<default> paremeter of I<add_argument>, or
documentation from Perldoc into the I<help> parameter. It does create
an empty I<help> parameter, however.

=item * Won't do anything special for Python argparse types
that aren't known to GetOpt (files, complex numbers, etc.).

=back


=item * Move Perldoc information into a Python triple-quoted string to
keep it out of the way. Nothing between C<=pod> and C<=cut> is changed.

=item * Change C<sub> to I<def>, and mostly adjust the parameter declarations
I<if> you did them like:

  sub foo {
    my ($x, $myFoo, $zorch) = @_;
  ...}

=item * Convert a wide variety of operators, such as:
  string and numeric comparisons (including C<< <=> >> and C<cmp>),
  C<.>, C<x> (for strings),
  C<||>, C<&&>,
  C<++>, C<-->, C<+=>, C<-=>, C<*+>, C</->,
  C<!>, C<< => >>,
  C<-f> and other file predicates,
  simple uses of ternary '?'
  and so on.

=item * Turn C<substr(s,start,length)> into I<s[start:start+length]>.
Will only work if there are no commas embedded within the arguments.

=item * Clean up some casts, lookups, and references like @{x}, $x->{y},
@$x, %@x, etc.

=item * Convert rudimentary file I/O calls.

=item * Rename common functions, such as C<int> to I<floor>,
C<lc> to I<lower>, C<push> to I<append>, C<sort> to I<sorted>, etc.
Change C<$ENV{}> to I<os.environ[]>.

=item * Turn C<print> and C<warn> into appropriate Python code.

= item * Break variables out of quoted strings, and add I<str>()
around them.
Doesn't do a very good job of it yet (mostly only works on full-line strings).
This is improving, along with support for various Perl quote-types.

=item * Change package-name separator from C<::> to I<.>. Change C<package>
keyword to I<class>. Change C<sub new> to I<def __init__>.
Does not yet change assignments to the object hash in new(), to make real
instance variables.

=back



=head2 Some things this script will NOT do

=over

=item * Convert perl ref() calls to Python type().

=item * Doesn't move functions so they're defined before used.

=item * Doesn't  handle regexes using other than C</> as delimiter.

=item * Doesn't support C<do { }>.

=item * Doesn't do much to move assignments outside of C<if> conditions.

=item * Doesn't introduce or normalize indentation, other than
expand tabs (default width: 4, see I<--tabs>).
Use an editor or pretty-printer if needed before using this script.

=item * No support for most Perl reserved variables:
C<$/>, C<$\>, C<$`>, C<$&>, C<$'>, C<$_[]>, etc.

=item * Some, but incomplete, support for Perl references:
C<$self>, C<\$>, C<\@>, C<\%>, C<@$>, C<%$>, etc.

=item * Doesn't catch C<x> operators with anything but a quoted string before.

=item * Doesn't do much with packages and references.
Doesn't do anything at all about packages you C<use>.

=item * Doesn't indent I<def> within classes.

=item * Weak support for inline subs (such as for C<sort> or C<Getopt> actions).

C<grep>, C<oct>, C<chop>, C<splice>, C<lcfirst>, C<ucfirst>,
C<tr///>, C<study>, C<pack>, C<unpack>, C<values>, C<map>,
C<eof>, C<printf>, C<readline>, C<stat>, C<sprintf>,
C<binmode>, C<opendir>, C<readdir>,
C<redo>, C<wantarray>, C<caller>, C<use>, C<require>,
C<tie>,

=item * Doesn't handle C<exec>, C<fork>, etc.


=item * Per filehandle special variables

=over

=item * B<< $| >>

If set to nonzero, forces a flush after every write or print

=item * B<< $% >>

Current page number

=item * B<< $= >>

Current page length

=item * B<< $- >>

Number of lines left on the page

=item * B<< $~ >>

Name of the current report format

=item * B<< $^ >>   Name of the current top-of-page format

=back


=item * Local special variables

=over

=item * B<< $1..$9 >>   Contains the subpattern from the corresponding set of parentheses in the last pattern matched. I<Renamed to C<mat.group(n)>, because regex matches are changed to assign to C<mat>.

=item * B<< $& >>

Contains the string matched by the last pattern match

=item * B<< $` >>

The string preceding whatever was matched by the last pattern match, not counting patterns matched in nested blocks that have been exited already.

=item * B<< $' >>

The string following whatever was matched by the last pattern match, not counting patterns matched in nested blockes that have been exited already.

=item * B<< $+ >>

the last bracket matched by the last search pattern. This is useful if you don't know which of a set of alternative patterns matched.

=back


=item * Global special variables

=over


=item * B<< $_ >>   The default input and pattern-searching space. I<Renamed to dftVar>

=item * B<< $. >>

The current input line number of the last filehandle that was read.

=item * B<< $/ >>

The input record separator, newline by default.

=item * B<< $\ >>

The output record separator for the print operator.

=item * B<< $, >>

The output field separator for the print operator.

=item * B<< $" >>    This is similar to $, except that it applies to array values interpolated into a double-quoted string (or similar interpreted string). Default is space.

=item * B<< $# >>

The output format for numbers display via the print operator.

=item * B<< $$ >>

The process number of the Perl running this script.

=item * B<< $? >>    The status returned by the last pipe close, backtick(``) command or system operator.

=item * B<< $* >>    Set to 1 for multi-line matching within a string, 0 to tell Perl that it can assume that strings contain a single line, for the purpose of optimizing pattern matches. Default is 0

=item * B<< $0 >>

Contains the name of the file containing the Perl script being executed.

=item * B<< $[ >>

The index of the first element in an array, and of the first character in a substring.

=item * B<< $] >>    The first part of the string printed out when you say perl -v.

=item * B<< $; >>    The subscript separator for multi-dimensional array emulation.

=item * B<< $! >>

If used in a numeric context, yields the current value of errno, with all the usual caveats.

=item * B<< $@ >>    The Perl syntax error or routine error message from the last eval, do-FILE, or require command.

=back


=head2 How to make Perl code convert better

=over

=item * Use consistent whitespace and indentation.

=item * Break up complicated embedded constructions into more, simpler
ones. For example, don't nest C<?>, C<substr>(), etc.

=item * Always break after the C<{> that starts a block,
before the C<}> that ends one, and after C<;> (except in C<for>).

=item * Use function parentheses.

=item * Always copy C<sub> arguments from C<@_> to named variables to use,
on the line right after the C<sub name {>.
    my ($x, $y, $z) = @_;

=item * Use C<< () >> around all conditions, even in shortcuts
like C<(cond) && action;>.


=back



=head1 Options

=over

=item * B<--getOptVar>

If you create a hash of the argument definitions as a separate variable,
instead of just passing them all as arguments to C<getOpt::Long()>, then you
must specify the variabe name on this option.

=item * B<--quiet> OR B<-q>
Suppress most messages.

=item * B<--singleQuoteOptions>

Declare long option names to start with "-" (default is to use "--").

=item * B<--tabs> I<n>

Expand tabs assuming tab-stops are every I<n> columns (default: 4).

=item * B<--trace>

Give lots of detail on regex operations. See also I<--verbose>.

=item * B<--verbose>

Add more messages (repeatable). See also I<--trace>.

=item * B<--version>

Show version info and exit.

=back



=head1 Known Bugs and Limitations / To do list

Many.

Major:
    Fix argparse handling to handle "my %getOptHash = ("...
    Option to use my newer argparse (ref MarkuphelpFormatter, use flag options)

Problems:
    with tests of substr() vs. 0, change to try...except
    handle multi-line quotes better (esp. qw)
    Turns some line-final '{' that open hashes, into ':'.
    {} left in {z} ??
    do *something* with $/, etc. (now loses the '$')
    move file arg for print (r'\bprint\s+(\w+)\s+')

    Flow constructs:
        toasts 'if' even if only got ==, not =
        sometimes fails to indent 'if'
        swap "if (x = ...)" to "x = ...\nif(x)" in general?
        leaves line-final ' +' on some 'if's
        Gets confused on some if/for w/ block on same line.
    Sorting:
        sort keys x (lose 'keys')
        sorted keys ... -> sorted(foo, key=foo.get, cmp=compfunction)
        sort(a,b) convention
    Constructors:
        self{\w+} goes to [], should go to .
        self inits in new() should create items, not hash entries.
            self\[(\w+)\]   ->  self.\1
        constructors shouldn't return 'self'.
        new -> __init__; class -> self
        Finish -getOptVar.
    regexes:
        always puts in mat = re.sub... even inside an if.
        changes to put in match instead of sub don't seem to work.
        /= {/ vs. { for open-block vs. { in regex -- breaks when shouldn't
        backslashes the apostrophes around regexes
        re.sub loses RHS, at least if null
    printf/sprintf:
        turns %f in sprint to 'flt'??
        loses '%' in sprintf format strings.
    strings:
        ..." . $x . "...  -> '%s'...%(x)
    cosmetic:
        doesn't delete all the ";", and leaves blank lines and ";"-only lines
        space before final ':'
        extra space after 'not'
        indent 'sub' when after 'package'



=head1 Related commands

C<perl>, C<python>



=head1 Ownership

This work by Steven J. DeRose is licensed under a Creative Commons
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/?.

For the most recent version, see L<http://www.derose.net/steve/utilities/>.

=cut
"""
