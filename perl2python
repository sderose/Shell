#!/usr/bin/env python
#
# Rudimentary Perl -> Python translation assistant.
# Written 2011-09, by Steven J. DeRose.
#
import sys
import argparse
import re
import time
import datetime

__metadata__ = {
    "title"        : "perl2python",
    "description"  : "Rudimentary Perl -> Python translation assistant.",
    "rightsHolder" : "Steven J. DeRose",
    "creator"      : "http://viaf.org/viaf/50334488",
    "type"         : "http://purl.org/dc/dcmitype/Software",
    "language"     : "Python 3.7",
    "created"      : "2011-09",
    "modified"     : "2021-06-24",
    "publisher"    : "http://github.com/sderose",
    "license"      : "https://creativecommons.org/licenses/by-sa/3.0/"
}
__version__ = __metadata__["modified"]

descr = """
=Usage=

perl2python [options] file

A rudimentary `Perl` to '''Python''' translation assistant.

This script does not do a complete translation, but does handle many of
the tedious, repetitive, simple parts. Run some Perl code through
it, and then finish the translation by hand. You'll still have a lot of
small changes to make, but you won't have to remove thousands of semicolons,
change `{` to ''':''', take `$@%` off of variables
(leaving `sprintf("...%..."...)` intact),
rename functions (`lc`() to '''lower'''(), etc.).

''Note'': This mainly applies a long list of regex changes, line by line.

''Note'': A few errors that can be caught, will be reported inline with
comments starting `## PROBLEM`.


=head2 Some things this script will do (mostly)

* Change the shebang (`#!`) line.

* Put in '''import''' lines for common packages.

* Convert loops and conditions:
  if/elsif/else
  postfix `if` and `unless`;
  `(expr) ? y:z`;
  `(expr) && action`;
  `next` to '''continue''';
  `last` to '''break''';
  `for (my x=y; x<z; z++)` and similar simple cases
  and so on.

* Fix most `{}`, etc.

* Discard `my/our/local`, and the type-characters on variables.

* Rearrange `=~` and `!~` into Python '''re''' package forms.
Even change them to lstrip() and rstrip() when appropriate.

* Change regex matches to save the Python match object as '''mat''',
add $1 etc. to mat.group(1) etc. These will sometimes need manual cleanup.

* Change $_ to $dftVar (more will typically be needed since '''$_'''
is set automatically, and that doesn't translate easily).

* Convert `Getopt::Long` to Python's '''argparse'''.
However, there are some limitations, including:

** one argument definition per line (synonyms are handled, though).

** If you create a hash of the argument definitions as a separate variable,
instead of just passing them all as arguments to `getOpt::Long()`, then you
must specify the variabe name on the '''--getOptVar''' option to this script.

** Anonymous `sub`s for the action part don't work.

** Entries for '''--help''' and/or '''--version''' will be deleted, since
Python gives you those for free.

** Won't copy option-variable declarations from earlier (for
defaults), into the '''default''' paremeter of '''add_argument''', or
documentation from Perldoc into the '''help''' parameter. It does create
an empty '''help''' parameter, however.

** Won't do anything special for Python argparse types
that aren't known to GetOpt (files, complex numbers, etc.).


* Move Perldoc information into a Python triple-quoted string to
keep it out of the way. Nothing between `=pod` and `=cut` is changed.

* Change `sub` to '''def''', and mostly adjust the parameter declarations
'''if''' you did them like:

  sub foo {
    my ($x, $myFoo, $zorch) = @_;
  ...}

* Convert a wide variety of operators, such as:
  string and numeric comparisons (including `< <=` >> and `cmp`),
  `.`, `x` (for strings),
  `||`, `&&`,
  `++`, `--`, `+=`, `-=`, `*+`, `/-`,
  `!`, `< =` >>,
  `-f` and other file predicates,
  simple uses of ternary '?'
  and so on.

* Turn `substr(s,start,length)` into '''s[start:start+length]'''.
Will only work if there are no commas embedded within the arguments.

* Clean up some casts, lookups, and references like @{x}, $x->{y},
@$x, %@x, etc.

* Convert rudimentary file I/O calls.

* Rename common functions, such as `int` to '''floor''',
`lc` to '''lower''', `push` to '''append''', `sort` to '''sorted''', etc.
Change `$ENV{}` to '''os.environ[]'''.

* Turn `print` and `warn` into appropriate Python code.

= item * Break variables out of quoted strings, and add '''str'''()
around them.
Doesn't do a very good job of it yet (mostly only works on full-line strings).
This is improving, along with support for various Perl quote-types.

* Change package-name separator from `::` to '''.'''. Change `package`
keyword to '''class'''. Change `sub new` to '''def __init__'''.
Does not yet change assignments to the object hash in new(), to make real
instance variables.


=head2 Some things this script will NOT do

* Convert perl ref() calls to Python type().

* Doesn't move functions so they're defined before used.

* Doesn't handle regexes using other than `/` as delimiter.

* Doesn't support `do { }`.

* Doesn't do much to move assignments outside of `if` conditions.

* Doesn't introduce or normalize indentation, other than
expand tabs (default width: 4, see '''--tabs''').
Use an editor or pretty-printer if needed before using this script.

* No support for most Perl reserved variables:
`$/`, `$\\`, `$``, `$&`, `$'`, `$_[]`, etc.

* Some, but incomplete, support for Perl references:
`$self`, `\\$`, `\\@`, `\\%`, `@$`, `%$`, etc.

* Doesn't catch `x` operators with anything but a quoted string before.

* Doesn't do much with packages and references.
Doesn't do anything at all about packages you `use`.

* Doesn't indent '''def''' within classes.

* Weak support for inline subs (such as for `sort` or `Getopt` actions).

`grep`, `oct`, `chop`, `splice`, `lcfirst`, `ucfirst`,
`tr///`, `study`, `pack`, `unpack`, `values`, `map`,
`eof`, `printf`, `readline`, `stat`, `sprintf`,
`binmode`, `opendir`, `readdir`,
`redo`, `wantarray`, `caller`, `use`, `require`,
`tie`,

* Doesn't handle `exec`, `fork`, etc.

* Per filehandle special variables

* '' $| ''

If set to nonzero, forces a flush after every write or print

* '' $% ''

Current page number

* '' $= ''

Current page length

* '' $- ''

Number of lines left on the page

* '' $~ ''

Name of the current report format

* '' $^ ''   Name of the current top-of-page format


* Local special variables

* '' $1..$9 ''   Contains the subpattern from the corresponding set of
parentheses in the last pattern matched. I<Renamed to `mat.group(n)`,
because regex matches are changed to assign to `mat`.

* '' $& ''

Contains the string matched by the last pattern match

* '' $` ''

The string preceding whatever was matched by the last pattern match,
not counting patterns matched in nested blocks that have been exited already.

* '' $' ''

The string following whatever was matched by the last pattern match,
not counting patterns matched in nested blockes that have been exited already.

* '' $+ ''

the last bracket matched by the last search pattern. This is useful
if you don't know which of a set of alternative patterns matched.


* Global special variables

* '' $_ ''   The default input and pattern-searching space.
'''Renamed to dftVar'''

* '' $. ''

The current input line number of the last filehandle that was read.

* '' $/ ''

The input record separator, newline by default.

* '' $\\ ''

The output record separator for the print operator.

* '' $, ''

The output field separator for the print operator.

* '' $" ''    This is similar to $, except that it applies to array
values interpolated into a double-quoted string (or similar interpreted
string). Default is space.

* '' $# ''

The output format for numbers display via the print operator.

* '' $$ ''

The process number of the Perl running this script.

* '' $? ''    The status returned by the last pipe close, backtick(``)
command or system operator.

* '' $* ''    Set to 1 for multi-line matching within a string, 0 to
tell Perl that it can assume that strings contain a single line, for
the purpose of optimizing pattern matches. Default is 0

* '' $0 ''

Contains the name of the file containing the Perl script being executed.

* '' $[ ''

The index of the first element in an array, and of the first character
in a substring.

* '' $] ''    The first part of the string printed out when you say perl -v.

* '' $; ''    The subscript separator for multi-dimensional array emulation.

* '' $! ''

If used in a numeric context, yields the current value of errno, with all
the usual caveats.

* '' $@ ''    The Perl syntax error or routine error message from the
last eval, do-FILE, or require command.


=head2 How to make Perl code convert better

* Use consistent whitespace and indentation.

* Break up complicated embedded constructions into more, simpler
ones. For example, don't nest `?`, `substr`(), etc.

* Always break after the `{` that starts a block,
before the `}` that ends one, and after `;` (except in `for`).

* Use function parentheses.

* Always copy `sub` arguments from `@_` to named variables to use,
on the line right after the `sub name {`.
    my ($x, $y, $z) = @_;

* Use `< () `> around all conditions, even in shortcuts
like `(cond) && action;`.


=Options=

=over

* ''--getOptVar''

If you create a hash of the argument definitions as a separate variable,
instead of just passing them all as arguments to `getOpt::Long()`, then you
must specify the variabe name on this option.

* ''--quiet'' OR ''-q''
Suppress most messages.

* ''--singleQuoteOptions''

Declare long option names to start with "-" (default is to use "--").

* ''--tabs'' '''n'''

Expand tabs assuming tab-stops are every '''n''' columns (default: 4).

* ''--trace''

Give lots of detail on regex operations. See also '''--verbose'''.

* ''--verbose''

Add more messages (repeatable). See also '''--trace'''.

* ''--version''

Show version info and exit.

=back


=Known Bugs and Limitations / To do list=

Many.

Major:
    Fix argparse handling to handle "my %getOptHash = ("...
    Option to use my newer argparse (ref MarkuphelpFormatter, use flag options)

Problems:
    with tests of substr() vs. 0, change to try...except
    handle multi-line quotes better (esp. qw)
    Turns some line-final '{' that open hashes, into ':'.
    {} left in {z} ??
    do *something* with $/, etc. (now loses the '$')
    move file arg for print (r'\\bprint\\s+(\\w+)\\s+')

    Flow constructs:
        toasts 'if' even if only got ==, not =
        sometimes fails to indent 'if'
        swap "if (x = ...)" to "x = ...\\nif(x)" in general?
        leaves line-final ' +' on some 'if's
        Gets confused on some if/for w/ block on same line.
    Sorting:
        sort keys x (lose 'keys')
        sorted keys ... -> sorted(foo, key=foo.get, cmp=compfunction)
        sort(a,b) convention
    Constructors:
        self{\\w+} goes to [], should go to .
        self inits in new() should create items, not hash entries.
            self\\[(\\w+)\\]   ->  self.\\1
        constructors shouldn't return 'self'.
        new -> __init__; class -> self
        Finish -getOptVar.
    regexes:
        always puts in mat = re.sub... even inside an if.
        changes to put in match instead of sub don't seem to work.
        /= {/ vs. { for open-block vs. { in regex -- breaks when shouldn't
        backslashes the apostrophes around regexes
        re.sub loses RHS, at least if null
    printf/sprintf:
        turns %f in sprint to 'flt'??
        loses '%' in sprintf format strings.
    strings:
        ..." . $x . "...  -> '%s'...%(x)
    cosmetic:
        doesn't delete all the ";", and leaves blank lines and ";"-only lines
        space before final ':'
        extra space after 'not'
        indent 'sub' when after 'package'


=Related commands=

`perl`, `python`


=History=

* Written 2011-09, by Steven J. DeRose.

* 2011-09-19ff sjd: Fixed:
    toasted indentation (expandTabs?
    break lines at ";" early on?
    how to get at $1 etc. after =~ s///?
    shift @foo to foo.shift()
    sys.stdout.isatty()
    -- is confused; only change after \\w?
    spurious insertion of 1-os.path.getsize from ---s
    ? operator: create whole 'if' with newlines
    ditch 'new'
    ($x = $y) =~ ...
    XML tags in quotes turn into readline(tag)
    int goes to floor when it shouldn't (like in argparse)
    no type=string, action='store_true'
    for my $k (keys %foo) -> for k, v in foo ??
    spurious r""?
    class colon
    `...`
    newline at end of printed strings
    getopts version
    strip // from around regexes in split
    don't nuke % inside sprintf()
    Separate GetOpt conversion, so we can accumulate list of var names
    W/ GetOpt, deal with the prior inits.
    accumulate the options vars? use those vars later
    Handle shebang line at top, outside loop.
    Split and complile changes before main loop.
    (x]
    \\$ \\@ \\%
    x[y]->[z]
    [@%]\\{.*?\\}

* 2011-10-17 sjd: tweaks

* 2012-01-10 sjd: +=, -=, *=, /=, .=, ->, (\\s+, ; alone, preserve !=, ....

* 2012-01-12 sjd: Various regex tweaks for if, for, substr, =~, -->, ternary ?.
    Major upgrades to GetOpt() handling. Clean up mainline logic. "+" options.

* 2012-01-24 sjd: Major rewrite to handleGetOpt: Handle inverted options,
    set dest when needed, do aliases better, modularize.

* 2012-01-31 sjd: Minor tweaks. Add helpMessages. Fix list ops.
    Remove part-line comments early, then replace at end.

* 2014-04-25 Misc. clean-up. Code regexes as [ lhs, rhs ] instead of a string.
    Don't turn regex /g into flags="g" instead of nothing (or count=0)

* 2014-05-14: Better handling of @{$x}, for, while($x = readline()),...

* 2021-06-24: General update, fixes, add POD-to-MarkDown, better error
reporting and change tracing.


=Ownership=

Copyright 2011 by Steven J. DeRose. This work is licensed under a Creative Commons
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/].

For the most recent version, see L<http://www.derose.net/steve/utilities/>
or [https://www.github.com/sderose/utilities].


=Options=
"""

args = None

def info(msg):
    sys.stderr.write("Info: %s\n" % (msg))
def warn(msg):
    sys.stderr.write("Warning: %s\n" % (msg))
def error(msg):
    sys.stderr.write("Error: %s\n" % (msg))
def flag(msg):  # Report and put msg inline
    sys.stderr.write("Error: %s\n" % (msg))
    print("### ERROR: %s" % (msg))
def fatal(msg):
    sys.stderr.write("Fatal: %s\n" % (msg))
    sys.exit()

delta = chr(0x0394)


###############################################################################
# Should rename any Perl variables with these names (not used yet)
#
reservedWords = [
    "and",      "assert",   "break",    "class",    "continue",
    "def",      "del",      "elif",     "else",     "except",
    "exec",     "finally",  "for",      "from",     "global",
    "if",       "import",   "in",       "is",       "lambda",
    "not",      "or",       "pass",     "print",    "raise",
    "return",   "try",      "while",

    "Data",     "Float",    "Int",      "Numeric",  "Oxphys",
    "array",    "close",    "float",    "int",      "input",
    "open",     "range",    "type",     "write",    "zeros",

    "acos",     "asin",     "atan",     "cos",      "e",
    "exp",      "fabs",     "floor",    "log",      "log10",
    "pi",       "sin",      "sqrt",     "tan"
    ]
reservedExpr = r"\$(" + "|".join(reservedWords) + r")\b"


###############################################################################
# Default help messages to supply for common GetOptLong option names.
#
helpMessages = {
    "delim"          : "Field separator.",
    "quote"          : "Field quoting character.",
    "clean"          : "Recode control characters for readability.",
    "noclean"        : "Leave control characters as-is.",
    "color"          : "Colorize the output.",
    "nocolor"        : "Don't colorize the output.",
    "fields"         : "Names/numbers of fields to display (repeatable).",
    "files"          : "Path(s) to input data.",
    "iencoding"      : "Set the input character set (not yet).",
    "ilineends"      : "Style of line-ends to use (M|U|D)",
    "numberFields"   : "Show field numbers as well as field names.",
    "nonumberFields" : "Don't show field numbers as well as field names.",
    "pause"          : "Pause after each record (unfinished).",
    "nopause"        : "",
    "quiet"          : "Suppress most messages.",
    "noquiet"        : "",
    "verbose"        : "Add more messages (repeatable).",
    "width"          : "How many columns to leave for field labels.",
    #
    # For CSV package
    #
    "comment"        : "Ignore records beginning with this string.",
    #"delim"          : "Field separator (default: tab).",
    "escape"         : "Character to escape quotes inside quotes.",
    "header"         : "There is a header record, providing field names",
    "noheader"       : "There is NO header record, providing field names",
    "nlInQuotes"     : "Allow newlines within quoted fields.",
    "nonlInQuotes"   : "Do not allow newlines within quoted fields.",
    #"quote"          : "Character used to quote field values (default: '\"').",
    "qdouble"        : "Allow a quote inside quotes via '\"\"'.",
    "noqdouble"      : "Do not allow a quote inside quotes via '\"\"'.",
    "stripFields"    : "Remove leading/trailing whitespace from fields.",
    "nostripFields"  : "Do not remove leading/trailing whitespace from fields.",
    "stripRecords"   : "Remove leading/trailing whitespace from records.",
    "nostripRecords" : "Do not remove leading/trailing whitespace from records."
    }


###############################################################################
# An ordered list of regex changes.
#
changes = [
    # Remove trailing spaces to simplify many later regexes
    [ r"\s+$/",                             r""                     ],
    [ r"^(\s*)([^#]*?;)\s*([^\s#])",        r"\1\2;\n\1\3"          ], # ????


    ###########################################################################
    # Packages and inits
    #
    [ r"^\s*\buse strict\b",
        r"import sys\nimport os\nimport re\nimport subprocess" +
        r"\nimport string\n" + r"import math\n" ],
    [ r"^\s*\buse Getopt\.Long",                  r"import argparse"      ],
    [ r"^\s*\buse ",                              r"import "              ],


    ###########################################################################
    # Regex match/change
    # (maybe also change simple cases to lstrip/rstrip)
    # (these are not careful enough about single/double/other quotes)
    #
    [ r"^(\s*)\(\$(\w+) = \$(\w+)\) =~ s", r"\1\2 = \3\n\1\1 =~ s"                     ],

    # =~ m// and !~ m// (and assign to 'mat' in case later code uses \1)
    #
    [ r"\$(\w+)\s*=~\s*m/^([^/]+)/g\b",    r"mat = re.match(r'\2', \1)"                ],
    [ r"\$(\w+)\s*=~\s*m/^([^/]+)/(\w+)",  r"mat = re.match(r'\2', \1, flags=\"\3\")"  ],
    [ r"\$(\w+)\s*=~\s*m/^([^/]+)/",       r"mat = re.match(r'\2', \1)"                ],

    [ r"\$(\w+)\s*=~\s*m/([^/]+)/g\b",     r"mat = re.search(r'\2', \1, count=0)"      ],
    [ r"\$(\w+)\s*=~\s*m/([^/]+)/(\w+)",   r"mat = re.search(r'\2', \1, flags=\"\3\")" ],
    [ r"\$(\w+)\s*=~\s*m/([^/]+)/",        r"mat = re.search(r'\2', \1)"               ],

    [ r"\$(\w+)\s*!~\s*m/([^/]+)/(\w+)",   r"not re.search(r'\2', \1, flags=\"\3\")"   ],
    [ r"\$(\w+)\s*!~\s*m/([^/]+)/",        r"not re.search(r'\2', \1)"                 ],

    # =~ s/// and remember that Perl changes the string in place...
    #
    [ r"\$(\w+)\s*=~\s*s/\^\\s+//",         r"\1 = \1.lstrip()"                         ],
    [ r"\$(\w+)\s*=~\s*s/\\s+\$//",         r"\1 = \1.rstrip()"                         ],
    [ r"\$(\w+)\s*=~\s*s/([^/]+)/([^/]+)/(.*)", r'\1 = re.sub(r\'\2\', \3, \1, flags="\4")' ],
    [ r"\$(\w+)\s*=~\s*s/([^/]+)/([^/]+)/", r'\1 = re.sub(r\'\2\', \3, \1)'             ],


    ###########################################################################
    # Flow of control
    #
    [ r"^(\s*)if \((\s*my\s+)?\$(\w+)\s*=\s*(.*)\)\s*{",
                                            r"\1\3 = \4\n\1if (\3):"    ],
    # if
    #
    [ r"(\bif\s*\([^\)]*\))\s*{",           r"\1:"                      ],
    [ r"^(\s*)if\s*(\([^{}]*\))\s*{(\s*\S+)?\s*$", r"\1if \2:\n\1    \3" ],
    [ r"\belsif\s*(\S.*)\s*{",              r"elif \1:"                 ],
    [ r"\belse\s*{",                        r"else:"                    ],
    [ r"^(\s*)(.*)\bunless\s*(\(.*?\));",   r"\1if (not \3):\n\1 \2"    ],
    [ r"^(\s*)(\S.+?) unless (\(.*\));",    r"\1if (not \3):\n\1    \2" ],
    [ r"^(\s*)(\S.+?) if (\(.*\));",        r"\1if (\3):\n\1    \2"     ],

    # for
    #
    [ r"\bfor\s*\((my\s+)?\$(\w+)\s*=\s*([^;]*);" +
      r"\s*\$\w+\s*<=?\s*([^;]*);" +
      r"\s*\$\w+\s*(\+\+|\+=\s*1)\)\s*{",
                                            r"for \2 in range([\3,\4]):" ],
    [ r"\bfor\s*\((my\s+)?\$(\w+)=(\d+);\s*\$\2\s*<=\s*(.*?);\s*\$\2\+\+\) {",
                                            r"for \2 in (range(\3,\4+1)):"  ],
    [ r"\bfor (my )?(\S+) \(keys (.*)\) {", r"for \2 in (\3):"          ],
    [ r"\bfor (my )?(\S+) \((.*)\) {",      r"for \2 in (\3):"          ],
    [ r"\bforeach\s*(my\s+)?(\w+)\s*(.*?)", r"for \2 in (\3)"           ],

    # other flow of control
    #
    [ r"\bwhile (\([^{]+\)) {",             r"while (\1):"              ],
    [ r"\bnext\b",                          r"continue"                 ],
    [ r"\blast\b",                          r"break"                    ],
    [ r"\bexit\b",                          r"sys.exit"                 ],

    # Short-cut AND and OR
    #
    [ r"^(\s*)(\(.*?\)) &&\s*",             r"\1if \2:\n\1    "         ],
    [ r"^(\s*)(\(.*?\)) \|\|\s*",           r"\1if (not \2):\n\1    "   ],

    # Ternary ?... (not really right...).
    #
    [ r"^(\s*)(my\s+)([$@%]\w+)\s*=\s*(\(.*?\))\s*\?(.*)\s*:\s*(.*);",
                        r"\1if \4:\n\1    \3 = \5\n\1else:\n\1    \3 = \6" ],
    [ r"\^(\s*)\((.*?)\) \|\| ",            r"\1if (not \2):\n\1     "  ],


    ###########################################################################
    # Functions
    #
    [ r"\bsort keys ([$\w+]+|%{[$\w+]+})",  r"sorted(\1, key=\1.get)"   ],
    [ r"\bsort\b",                          r"sorted"           ],

    [ r"\bint\(\b",                         r"floor("           ],
    [ r"\bdelete\b",                        r"del"              ],
    [ r"\bundef\b",                         r"None"             ],

    #[ r"\bpackage (.*);",                  r"class \1:"        ],
    [ r"\bbless\b",                         r"# bless"          ],
    [ r"\bdefined\b",                       r"None == "         ],
    [ r"= new ",                            r"= "               ],
    [ r"sub new ",                          r"  def __init__()" ],
    [ r"sub (\w+::)+(\w+) ",                r"  def \2"         ],

    [ r"\blc\s*\(",                         r" lower("          ],
    [ r"\buc\s*\(",                         r" upper("          ],
    [ r"\blength\b\(",                      r"len\("            ],
    [ r'\bjoin\(("[^"]"),\s*',              r'\1.join('         ],
    [ r'\bjoin\((\'[^\']\'),\s*',           r'\1.join('         ],
    [ r"\bchomp\s+([\$\w]+)",               r'\1 = strip(\1, "\n\r")' ], # ???
    [ r"\bsplit\(/(.*)/",                   r' re.split(\'\1\'' ],
    [ r"\bsubstr\(([^,]*?),([^,\)]*)\)",    r" \1[\2:]"         ], # ???
    [ r"\bsubstr\(([^,]*?),([^,]+?),([^,]*?)\)",
                                            r" \1[\2:\2+\3]"     ],
    [ r"\breverse\s*\(\$(\w+)\)",           r" \1[::-1]"         ],
    [ r"^(.*)\btranslate\s*\((.*?),(.*?),(.*?)\)",
            r"\1mytrans = maketrans(\3,\4)\n\1translate(\2,mytrans)" ],
    [ r"\bhex\s*\(",                        r" fromhex("         ],
    [ r"\btime\s*\(",                       r" gmtime("          ],

    [ r"\bopen\s*\(?(\w+),\s*>(.*?)\)?",    r'\1 = open(\2, "w");' ],
    [ r"\bopen\s*\(?(\w+),\s*<(.*?)\)?",    r'\1 = open(\2, "r");' ],
    [ r"\bclose\s*\(?(\w+)\)?",             r"\1.close()"         ],

    [ r'\bsprintf\(("[^"]),\s*',            r'\1.format('        ],
    [ r'\bprintf\(("[^"]),\s*',             r'print(\1 % ('      ],

    # Stack functions
    #
    [ r"\bpop @(\w+)\b",                    r"\1.pop()"          ],
    [ r"\bpush @(\w+)\s*,\s*(.+?)(\b|$|;)", r"\1.append(\2)"     ],
    [ r"\bshift @(\w+)\b",                  r"\1.pop(0)"         ],
    [ r"\bunshift @(\w+),\s*(.+?)\b",       r"\1.insert(0,\2)"   ],

    [ r"\bpop @{$(\w+)}\b",                 r"\1.pop"            ],
    [ r"\bpush @{$(\w+)}\s*,\s*(.+?)(\b|$|;)", r"\1.append(\2)"  ],
    [ r"\bshift @{$(\w+)}\b",               r"\1.pop(0)"         ],
    [ r"\bunshift @{$(\w+)},\s*(.+?)\b",    r"\1.insert(0, \2)"  ],


    ###########################################################################
    # Variable and subroutine definitions
    # (multi-line array/hash assignments don't have their () fixed)
    # Should discard 'my' etc. earlier??
    #
    [ r"^sub (.*)\s*{",                               r"def \1("          ],  # sub
    [ r"^(\s*)(my|local|our)\s+\$(\w+);",             r"\1\2 = None"      ],  # $x
    [ r"^(\s*)(my|local|our)\s+\@(\w+\s*)=\s*\(\);",  r"\1\2 = []"        ],  # @x = ()
    [ r"^(\s*)(my|local|our)\s+\%(\w+\s*)=\s*\(\);",  r"\1\2 = {}"        ],  # %x = ()
    [ r"^(\s*)my \(\s*(.*)\)\s*=\s*@_;",              r"\1\2):"           ],  # my (...)
    [ r"^\s*(my|local|our)\s+@(.*?)\s*=\((.*)\)$",    r"\1 = array([\2])" ],  # @x = array()
    [ r"^\s*(my|local|our)\s+@(.*?)\s*=\((.*)$",      r"\1 = array([\2"   ],  #
    [ r"^\s*(my|local|our)\s+%(.*?)\s*=\((.*)\)$",    r"\1 = {\2\}"       ],  # %x = {...}
    [ r"^\s*(my|local|our)\s+%(.*?)\s*=\((.*)$",      r"\1 = {\2"         ],  #
    [ r"\b(my|local|our)\s+[@%\$]",                   r""                 ],  # $x @x %x


    ###########################################################################
    # Reserved variables, system stuff, etc.
    #     Special variable are not done yet. See doc.
    #
    [ r"\$ENV\{(.*?)\}",                r'os.environ["\1"]'     ],  #
    [ r"\b[$@]ARGV",                    r"sys.argv"             ],  #
    [ r"\$_ ",                          r"$dftVar "             ],  #
    [ r"\$(\d)\b",                      r"mat.group(\1)"        ],  #
    [ r"= `(\w+) (.*)`",                r'= exec_command(["\1", "\2"])' ],

    [ r"\bscalar[ \(]+",                r"len("                 ],  #
    [ r'\bprint[ (](.*?)\\n"\)?;',      r'print(\1")'           ],  #
    [ r"\bprint[ (](.*?)\)?;",          r"print(\1)"            ],  #

    # I tend to start a new line after 'die' and 'warn' keywords,
    # so insert the "(". Still have to insert the ")" manually.
    #
    [ r"\b(die|warn|print)\s*$",        r"\1("                  ],  #

    # See also under handling of quoted lines....
    #
    [ r"^(\s*)\bdie\b(.*);",            r"\1print(\2) # DIE\n\1    exit(0)" ],
    [ r"\bwarn\s*\(?(.*)\)?\s*;",       r"sys.stderr.write(\1)" ],  #
    [ r"\bwarn\s*$",                    r"sys.stderr.write("    ],  #

    [ r"\$self->\{([^{}]+)\}",          r"self.\1"              ],  #
    [ r"->",                            r"."                    ],  #
    [ r"\$(\w+)(\.)?\{([^{}]+)\}",      r"\1[\3]"               ],  #


    ###########################################################################
    # File operations
    #    (happens *after* stripping variable prefix chars [$@%])
    #
    [ r"(?<!w)-r\s+\$?([^()]+)",        r"os.access(\1,os.R_OK)"    ],  # -w...
    [ r"(?<!w)-w\s+\$?([^()]+)",        r"os.access(\1,os.W_OK)"    ],
    [ r"(?<!w)-x\s+\$?([^()]+)",        r"os.access(\1,os.X_OK)"    ],
    [ r"(?<!w)-e\s+\$?([^()]+)",        r"os.path.exists(\1)"       ],
    [ r"(?<!w)-z\s+\$?([^()]+)",        r"os.path.getsize(\1)>0"    ],
    [ r"(?<!w)-s\s+\$?([^()]+)",        r"os.path.getsize(\1)"      ],
    [ r"(?<!w)-d\s+\$?([^()]+)",        r"os.path.isdir(\1)"        ],
    [ r"(?<!w)-f\s+\$?([^()]+)",        r"os.path.isfile(\1)"       ],
    [ r"(?<!w)-t\s+\$?([^()]+)",        r"\1.isatty()"              ],

    [ r"\bSTDIN\b",                     r"sys.stdin"                ],
    [ r"\bSTDOUT\b",                    r"sys.stdout"               ],
    [ r"\bSTDERR\b",                    r"sys.stderr"               ],

    # <...> for reading input file
    # Would be nice to pull this out when it's in an '[el]if'...
    [ r"^(\s+)while\s*\((\w+)\s*=\s*<(\$?\w+)>\)?\s*{",
        r"\1while(1):\n    \1\2 = \3.readline()\n    \1if (not \1): break" ],
    [ r"\s*=\s*<(\$\w+|[A-Z]+)>",       r"= \1.readline()"          ],


    ###########################################################################
    # Operators
    #
    # r"\s*%(\s+|$)",                   r"mod "       ],  ###
    [ r"=>",                            r":"          ],  # =>
    [ r"\s*\{(\s*#.*)$",                r":\1"        ],  # { # comment
    [ r"\s*\{\s*$",                     r":"          ],  # {
    [ r"\s*\}(\s*#.*)$",                r"\1"         ],  # } # comment
    [ r"\s*\}\s*$",                     r""           ],  # }
    [ r"\s+&&(\s+|$)",                  r" and "      ],  # &&
    [ r"(^|\s+)\|\|(\s+|$)",            r" or "       ],  # ||
    [ r"\.\.",                          r":"          ],  # range
    [ r"::",                            r"."          ],  # package-sep
    [ r'"\s+\.\s+\$',                   r'" + '       ],  # concat
    [ r'(\w)\s+\.\s+(["$])',            r'"\1 + \2'   ],  #
    [ r"\+\+",                          r" += 1"      ],  # ++
    [ r"([a-zA-Z])\-\-([^>])",          r"\1 -= 1\2"  ],  # -- but not -->
    # r"\b(\S)\s*([-+*/])=",            r"\1 = \1 \2" ],  ### += -= *= /=
    [ r" \.=(\s+|$)",                   r" += "       ],  # .= (concat)
    [ r" \.(\s+|$)",                    r" + "        ],  # . (concat)
    [ r'" x ',                          r' " * '      ],  # "foo" x 7
    [ r"(\$\w+) x ",                    r' "\1 * '    ],  # $var x 3
    [ r"%\$|@\$",                       r""           ],  # cast-from-ref
    [ r"\\[$@%]",                       r""           ],  # cast-to-ref
    [ R"\]->\[",                        r"]["         ],

    # Operators: comparison
    #
    [ r"(\S+)\s+<=>\s+(\S+)",           r" cmp(\1,\2)"  ],  # cmp() not in Python 3
    [ r"(\S+)\s+cmp\s+(\S+)",           r" cmp(\1,\2)"  ],
    [ r" lt ",                          r" < "          ],
    [ r" le ",                          r" <= "         ],
    [ r" gt ",                          r" > "          ],
    [ r" ge ",                          r" >= "         ],
    [ r" eq ",                          r" == "         ],
    [ r" ne ",                          r" != "         ],

    [ r"([( ])!([^=~])",                r" \1not \2"    ],


    ###########################################################################
    # Weird cleanup -- these were added to clean up problems discovered.
    # Deleting some of them would be nice.
    #
    [ r'(\("[^"]*\')[$@%](\w+)(\'[^"]*")',  r'\1" + \2 + "\3' ],
    [ r";\s*}:\s*$",                        r""            ], # ???
    [ r"^(\s*)(if\s*\(.*\))\s*{\s*(}\s*)$", r"\1\2:"       ], # if ()
    [ r"^(\s*)(if\b.*:)\s*(\S)",        r"\1\2:\n\1    \3" ],
    [ r"@\{(.*?)\}",                    r"\1"           ],
    [ r"@\[(.*?)\]",                    r"\1"           ],
    [ r"[$@%]([A-Za-z]+)",              r"\1"           ], # var names
    # r";\s*(#.*)$",                    r" \1"          ], ###
    # r"([^#\s])\s\s+",                 r"\1 "          ], ###
    [ r"\)\s+:\s*$",                    r"):"           ],
    # r"[\(\[\{]\s+",                   r"("            ], ###
    [ r"\.\[",                          r"["            ],
    # r"\.\{",                          r"["            ], ###
    [ r"^(\s*def .*)\s*\(\s+",          r"\1("          ],
    [ r"\s*;\s*$",                      r""             ], # leftover ";"
    [ r"^\s*;\s*",                      r""             ],

    # Round margins to multiple of 4
    #
    [ r"(\S)  +=",                      r"\1 ="         ],
    [ r"^ (\S)",                        r"\1"           ],
    [ r"^     (\S)",                    r"    \1"       ],
    [ r"^         (\S)",                r"        \1"   ],
    [ r"\(\s+",                         r"("            ],
    [ r"\bif  +",                       r"if "          ],
    [ r"\bnot  +",                      r"not "         ],

] # END OF CHANGE LIST


###############################################################################
# Enabled via --specialVars
#
TODO = "#TOTO "
specialVarChanges = [
    [ r"\$\|\b",    TODO+r"\1#" ], # If set to nonzero, forces flushes
    [ r"\$%\b",     TODO+r"\1#" ], # Current page number
    [ r"\$=\b",     TODO+r"\1#" ], # Current page length
    [ r"\$-\b",     TODO+r"\1#" ], # Number of lines left on the page
    [ r"\$~\b",     TODO+r"\1#" ], # Name of the current report format
    [ r"\$\^\b",    TODO+r"\1#" ], # Name of the current top-of-page format

    # [ r"\$\d\b",  TODO+r"\1#" ], # Subpattern from last match. I<Renamed to `mat.group(n)`
    [ r"\$&\b",     TODO+r"\1#" ], # String matched by the last pattern match
    [ r"\$`\b",     TODO+r"\1#" ], # String preceding whatever was matched
    [ r"\$'\b",     TODO+r"\1#" ], # String following whatever was matched
    [ r"\$\+\b",    TODO+r"\1#" ], # Last bracket matched by last pattern

    [ r"\$_\b",     TODO+r"\1#" ], # Default input and pattern space. '''Renamed to dftVar'''
    [ r"\$\.\b",    TODO+r"\1#" ], # Current line number of the last filehandle read
    [ r"\$/\b",     TODO+r"\1#" ], # Input record separator
    [ r"\$\b",      TODO+r"\1#" ], # Output record separator for print
    [ r"\$,\b",     TODO+r"\1#" ], # Output field separator for print
    [ r'\$"\b',     TODO+r"\1#" ], # Similar to $, except for array values in a "string"
    [ r"\$#\b",     TODO+r"\1#" ], # Output format for numbers via print.
    [ r"\$\$\b",    TODO+r"\1#" ], # Process number of the Perl running this script
    [ r"\$\?\b",    TODO+r"\1#" ], # Status of last pipe close, backtick(``) or system.
    [ r"\$\*\b",    TODO+r"\1#" ], # 1 for multi-line matching within a string
    [ r"\$0\b",     TODO+r"\1#" ], # Name of the Perl script being executed
    [ r"\$\[\b",    TODO+r"\1#" ], # Index of first element in array; character in string
    [ r"\$\]\b",    TODO+r"\1#" ], # First part of perl -v
    [ r"\$;\b",     TODO+r"\1#" ], # Subscript separator for array emulation.
    [ r"\$!\b",     TODO+r"\1#" ], # In numeric context, current value of errno
    [ r"\$@\b",     TODO+r"\1#" ], # Error message from last eval, do-FILE, or require
]


###########################################################################
# POD to Markdown
#
podChanges = [
    [ r"^=head1 (.*)",                  r"#\1#"           ],
    [ r"^=head2 (.*)",                  r"##\1##"         ],
    [ r"^=head3 (.*)",                  r"###\1###"       ],
    [ r"^=head4 (.*)",                  r"####\1####"     ],
    [ r"^=head5 (.*)",                  r"#####\1#####"   ],
    [ r"^=head6 (.*)",                  r"######\1######" ],
    # [ pod, cut, over, back, item '  -- SPECIAL
    # Skipping the repeatable I<<<<<...>>>>> cases.
    [ r"\bB<([^>]+)>",                   r"`\1`"          ],
    [ r"\bC<([^>]+)>",                   r"`\1`"          ],
    [ r"\bF<([^>]+)>",                   r"_\1_"          ],
    [ r"\bI<([^>]+)>",                   r"''\1''"        ],
    [ r"\bL<([^>]+)>",                   r"[\1]"          ],
    # E<sol> lt gt verbar html names decimal 127 0177 0x7F...
    # Leaving over and back so we can still see the nesting.
]

def compileRegexes() -> None:
    for i, c in enumerate(changes):
        if (args.trace):
            info("change %3d: s/%s/%s/" % (i, c[0], [c[1]]))
        if (len(c) != 2):
            raise ValueError("changes %3d is len %d, not 2." % (i, len(c)))
        try:
            c.append(re.compile(c[0]))
        except re.error:
            fatal("## Can't compile regex #%d: LHS: /%s/" % (i, c[0]))

    for i, c in enumerate(specialVarChanges):
        try:
            if (args.trace):
                info("specialVarChanges %3d: s/%s/%s/" % (i, c[0], [c[1]]))
            if (len(c) != 2):
                raise ValueError("specialVarChanges %3d is len %d, not 2." % (i, len(c)))
            re.compile(c[0])
        except re.error:
            fatal("Can't compile specialVarChanges regex #%d: LHS: /%s/" % (i, c[0]))


    for i, c in enumerate(podChanges):
        try:
            if (args.trace):
                info("podChanges %3d: s/%s/%s/" % (i, c[0], [c[1]]))
            if (len(c) != 2):
                raise ValueError("podChange %3d is len %d, not 2." % (i, len(c)))
            re.compile(c[0])
        except re.error:
            fatal("Can't compile podChanges regex #%d: LHS: /%s/" % (i, c[0]))


###############################################################################
#
def varsInString(s:str) -> str:
    """Expand variable references inside a Perl double-quoted string
    (may come in with ';' and/or comment at end)
    (perhaps should also drop a final "\\n"?)
    """
    if (args.oldVarsInString): return varsInString1(s)
    else: return varsInString2(s)

def varsInString1(s:str) -> str:
    # Strip comment if any (imperfect))
    s = s.rstrip(" ;")
    com = ""
    mat = re.search(r"\s*#[^'\"]*$", s)
    if (mat):
        com = s[mat.start():]
        s = s[0:mat.start()]

    buf = ""
    re.sub(r'"(.*?(?<!\\))"', varSubFunc, s)
    s = re.sub(r'\\n"$', "\"", s)
    return s+com

def varSubFunc(mat):
    """Split the string at each $x{}, $x[], or $x, and make it a concat
    instead. Could instead switch to .format(), but it doesn't seem any easier.
    """
    x = mat.group(1)
    x = re.sub(r"\$(\w+)\{(.*?)\}",   r'" + str(\1[\2]) + "', x)
    x = re.sub(r"\$(\w+)\[(.*?)\]",   r'" + str(\1[\2]) + "', x)
    x = re.sub(r"\$(\w+)",            r'" + str(\1) + "'    , x)
    return x


###############################################################################
#
def varsInString2(s:str) -> str:
    """Extract variables from inside quotes, and handle Perl's many quote types.

     ==> Move to top level so only unquoted stuff goes to the regexes. Requires
     separately collecting stuff outside of quotes, and passing that through
     with some substitutes for the quotes bits inserted then replaced.

     (see http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators)

     Customary Generic       Meaning           Interpolates
     --------- -------       -------           ------------
           ''   q{}          Literal           no
           ""  qq{}          Literal           yes
           ``  qx{}          Command           yes*
               qw{}          Word list         no
           //   m{}          Pattern match     yes*
               qr{}          Pattern           yes*
                s{}{}        Substitution      yes*
               tr{}{}        Transliteration   no (but see below)
                y{}{}        Transliteration   no (but see below)
              <<EOF          here-doc          yes*

       * unless the delimiter is ''.

     To do:
         insert first/last qw quotes
         insert system call for back-quotes
         handle s/tr/y 2nd argument (must 1st and 2nd use same delim?

    """
    if (args.varsInString):
        warn("===>%s<===" % (s))
    buf = ""              # Build up the result here
    inQuote = ""          # What kind of Perl quote are we in ("" = none)
    outQuote = ""         # String we expect in Perl, to end the quote
    delim = ""            # What char after inQuote, as delimiter?
    interpolate = 0       # Are variables recognized in this kind of quote?
    toMakeClose = ""      # What to issue for Python at close of quote

    indent = re.sub(r"\S.*$", "", s) # Leading whitespace in case of new '\n'

    # NO 'continue', please, pos is incremented at the dn
    lastPos = -1
    pos = 0               # Current offset in source string
    while (pos < len(s)):
        if (pos == lastPos):
            fatal("pos not incemented from %d in '%s^^^%s'." %
                (lastPos, s[0:lastPos], s[lastPos:]))
        lastPos = pos

        c = s[pos]

        if (inQuote == ""):                 # OUTSIDE QUOTES
            if (c == "#"):                                  # comment!
                buf += s[pos:]
                pos = len(s)
                toMakeClose = c
            elif (c == '"'):                                  # start double
                buf += c
                inQuote = c
                interpolate = 1
                outQuote = c
                toMakeClose = c
            elif (c == "'"):                                  # start single
                buf += c
                inQuote = c
                interpolate = 0
                outQuote = c
                toMakeClose = c
            elif (c == "`"):                                  # start back
                buf += 'exec_command("""',
                inQuote = c
                interpolate = 1
                outQuote = c
                toMakeClose = '""")'
            elif (c == ";"):
                buf += "\n" + indent
            elif (c == "<" and re.match(r'<<EOF',s[pos:])):   # start 'here'
                buf += '"""'
                pos += 4
                inQuote = "<<EOF"
                interpolate = 1
                outQuote = "EOF"
                toMakeClose = '"""'
            else:
                mat = re.match(r"(q|qq|qx|qw|m|qr|s|tr|y)(#|\s*\W)", s[pos:]) # others
                if (mat):
                    inQuote = mat.group(1)
                    interpolate = 0
                    if (re.match("qq|qx|m|qr|s",mat.group(1))):
                        interpolate = 1
                    twoArgs = 0
                    if (re.match("s|tr|y",mat.group(1))):
                        twoArgs = 1
                    pos += len(inQuote)
                    delim = mat.group(2)
                    delim = re.sub(r"^\s+","",delim)
                    if (delim == "("):
                        delim = ")"
                    elif (delim == "["):
                        delim = "]"
                    elif (delim == "{"):
                        delim = "}"
                    elif (delim == "'"):
                        interpolate = 0
                    outQuote = delim
                    buf += '"""'
                    toMakeClose = '"""'
                else:
                    buf += c                                  # just copy

        else:                               # INSIDE QUOTES
            if (c == "\\"):                                   # \-char
                buf += c + s[pos]
            elif (re.match(outQuote,s[pos:])):                # close quote
                buf += toMakeClose
                toMakeClose = ""
                inQuote = ""
            elif (interpolate and c in [ "$", "@" ]):         # variable
                mat = re.match(r".\w+",s[pos:])
                if (mat):
                    buf += outQuote + " + str(" + mat.group() + ") + " + inQuote
                    pos = mat.end()
                else:
                    buf += '"\n## PROBLEM: syntax within quote\n"'
            elif (inQuote == "qw"):                           # quote words
                mat = re.match(r"\s+", s[pos:])
                if (mat):
                    buf += '", "'
                    pos += len(mat.group())
                else:
                    buf += c
            else:
                buf += c                                      # just copy

        pos += 1                            # ALWAYS INCREMENT
    # while some s left
    return(buf)


###############################################################################
#
def oneArg(n, v, quote:bool=True) -> str:
    """Handle GetOpt::Long (option parser) package. It is separate because it:
     * takes several regexes out of an already-long list
     * doesn't collide with similar code elsewhere
     * accumulates option variable names so we can update them later
     # does some fancy parsing for option types, repetition flags, etc.

     To do:
         write out sub and convert_bases definitions
    """
    if (not v):
        return("")
    if (quote):
        return((n+'="'+v+'",').ljust(24))
    else:
        return((n+'='+v+',').ljust(24))

def niceText(names, dest=None, nargs=None, action=None, typ=None) -> str:
    theOpt = 'parser.add_argument(\n'

    # Separate any "|" aliases
    for i in (range(len(names))):
        n = names[i]
        if (len(n) == 1 or args.singleQuoteOptions):
            theOpt += '"-' + n + '", '
        else:
            theOpt += '"--' + n + '", '

    # Add any options
    theOpt += '\n    '
    theOpt += oneArg('type', typ, quote=False)
    if (dest != names[0]):
        theOpt += oneArg('dest', dest)
    theOpt += oneArg('action', action)
    theOpt += oneArg('nargs', nargs)
    helpMsg = ""
    if (names[0] in helpMessages): helpMsg = helpMessages[names[0]]
    theOpt += '\n    help="' + helpMsg + '")\n'

    return(theOpt)

def makeOneOption(nameList, suffix, varType, varName, append) -> str:
    """Sort out just what argparse options we need, based on GetOpt flags.
     Let niceText() above, do the layout from that.
    """
    buf = ""
    # Only specify dest, if the Perl varName not same as option name.
    dest = None
    if (varName and varName != nameList): dest = varName
    action = ""
    if (append == True):
        action = "append"

    names = re.split(r'\|', nameList)
    if   (suffix == ""):                      # flag
        if (not action): action = 'store_true'
        buf = niceText(names, dest=dest, action=action)
    elif (suffix == "+"):                     # increment
        buf = niceText(names, dest=dest, action='count')
    elif (suffix == "=s"):                    # string
        buf = niceText(names, dest=dest, action=action, typ='str')
    elif (suffix == "=n" or suffix == "=i"):  # int
        buf = niceText(names, dest=dest, action=action, typ='int')
    elif (suffix == "=f"):                    # float
        buf = niceText(names, dest=dest, action=action, typ='float')
    elif (suffix == "=o"):                    # int 077 0xff 0b11
        if (not action): action = 'convert_bases'
        buf = niceText(names, dest=dest, action=action)
    elif (suffix == "!"):                     # invertible (make 2 options)
        actionT = action
        actionF = action
        if (not action):
            actionT = 'store_true'
            actionF = 'store_false'
        buf = niceText(names, action=actionT, dest=names[0])
        negatedNames = []
        for n in (names):
            negatedNames.append('no'+n)
        buf += niceText(negatedNames, dest=dest, action=actionF)
    else:
        buf += "### PROBLEM: Unknown GetOpt option suffix '" + suffix + "'\n"
        # such as =s@ =n% =f{3,5}
    return(buf)

def addBoilerPlate() -> str:
    """Provide fixed text to go at the end of the option dcls.
    """
    bp = """
    parser.add_argument("files",
        type=str, nargs=argparse.REMAINDER,
        help="Path(s) to input data.")
    args = parser.parse_args()
"""
    return(bp)

def handleGetOpt(ifh):
    """Parse the actual Getopt::Long call and convert to Python.
    This may be overly picky about layout....
    """
    optionsResult = """
        parser = argparse.ArgumentParser(
            version="Version of  " + __version__,
            description="")
        """
    lastLineBad = 0

    global recnum
    recnum = 0
    while (True):
        rec = ifh.readline()
        if (not rec):                                       # EOF
            flag("EOF found in middle of GetOpt")
            break
        recnum = recnum + 1

        if (re.match(r"\s*\)\s*;", rec)):                    # end of GetOpt()
            break
        if (re.match(r"^\s*#", rec)):                        # comment
            print(rec)
            continue
        if (re.match(r"^\s*$", rec)):                        # blank line
            print(rec)
            continue

        # Special case reserved options
        if (re.match(r'\s*"version"\s+=>', rec)):            # -version
            continue
        if (re.match(r'\s*"(h\|)?help[^"]*"\s+=>', rec)):    # -help
            continue

        # If we get here it should be a real option, so parse & convert
        #
        mat = re.match(
            r'\s*"([|\w]*)(!|=[nsof]|\+)?"(\s+)=>\s*(\\[@$%]\w+,|sub\s*.*)$',
            rec)
        if (not mat):
            if (not lastLineBad): # don't issue lots of messages in a row
                flag("in GetOpt (line #" + str(recnum) + "):")
                lastLineBad = 1
            print("##" + rec)
            continue

        lastLineBad = 0
        optName = mat.group(1)
        optSuff = mat.group(2)
        alignSp = mat.group(3)
        rhs     = mat.group(4)
        varType = rhs[0:2]
        varName = rhs[2:-1]
        append  = False

        if (varType == "\\$"):
            pass
        elif (varType == "\\@"):
            append = True
        elif (varType == "\\%"):
            flag("%-targets not yet supported")
        elif (re.match(r"sub\s+{", rhs)):
            flag("sub{} target for '" + optName + "': " + rhs)
            varName = ""
        else:
            flag("unknown rhs for '" + optName + "': " + rhs)
            varName = ""

        # Put together the option declarations
        #
        optionsResult += makeOneOption(
            optName,optSuff,varType,varName,append)
    # until end of GetOpt() call

    optionsResult += addBoilerPlate()
    print(optionsResult)
# handleGetOpt

def notableDiff(s1:str, s2:str) -> bool:
    return (norm(s1) != norm(s2))

def norm(s:str) -> str:
    """Neutralize ubiquitous changes, so --verbose reports less fluff.
    """
    s = s.strip().rstrip(":{} \t")
    s = re.sub(r"=>", ":", s)
    s = re.sub(r".=", "+=", s)
    s = re.sub(r"\belsif\b", "elif", s)
    s = re.sub(r"[$@%]", "", s)
    return s


###############################################################################
# Main
#
def anyInt(x:str) -> int:
    return int(x, 0)

def processOptions():
    try:
        from BlockFormatter import BlockFormatter
        parser = argparse.ArgumentParser(
           description=descr, formatter_class=BlockFormatter)
    except ImportError:
        parser = argparse.ArgumentParser(
        description=descr)

    parser.add_argument("--getOptVar", type=str,
        help="Assume this variable is where getOptLong arguments are built.")
    parser.add_argument("--oldVarsInString", action="store_true", default=True,
        help="Use old version of variable interpolation for strings.")
    parser.add_argument("--singleQuoteOptions", action="store_true",
        help='Prefix "-" instead of "--" for long option names.')
    parser.add_argument("--specialVars", action="store_true",
        help="Convert PERL special-variables, too.")
    parser.add_argument("--tabs", type=int, default=4,
        help="Assume tab stops this far apart.")
    parser.add_argument("--trace", action="store_true",
        help="Display regexes while compiling and running.")
    parser.add_argument("--varsInString", action="store_true",
        help="Display each string before doing substitutions in it.")
    parser.add_argument("--verbose", "-v", action="count", default=0,
        help="Provide more tracing information.")

    parser.add_argument("files",
        type=argparse.FileType("r"), nargs=argparse.REMAINDER,
        help="Path to a Perl file to (partly) convert to Python.")

    args0 = parser.parse_args()
    return args0


###############################################################################
#
args = processOptions()

recnum      = 0   # What line number are we at?
inpod       = 0   # State: inside a Perldoc pod...cut block?
podIndent   = 0   # Track =over/=back levels
seenPackage = 0   # Has there been a 'package' line yet?

# Compile the regexes.
#
expected = 162
nChanges = len(changes)
if (nChanges != expected):
    sys.stderr.write(
        "Warning: Expected %d changes, but found %d; did you mean to change that?\n" %
        (expected, nChanges))

compileRegexes()


###############################################################################
# Read the Perl code and apply the regexes to each line (handle comments,
# perldoc pod...cut blocks, whole-line strings, package,
# and GetOpt() calls specially).
#
ifh0 = args.files[0]
if (not ifh0):
    fatal("Can't open input file '" + args.files[0] + "'")
info("file: '"+str(ifh0)+"'")

rec0 = ifh0.readline()
recnum = recnum + 1
while (rec0):
    recnum += 1
    if (args.verbose > 1): info("#"+str(recnum)+": "+rec0)
    rec0 = re.sub(r"\n", "", rec0)
    if (args.verbose > 1): info("\n*** [%4d]: '%s'" % (recnum, rec0))

    if (inpod > 0):                                     # in perldoc
        if (re.match(r"=cut", rec0)):
            print("\"\"\" # End of doc\n\n")
            inpod = 0
        elif (re.match(r"=over", rec0)):
            podIndent += 1
        elif (re.match(r"=back", rec0)):
            podIndent -= 1
            if (podIndent < 0):
                error("POD indent < 0 at record %d." % (recnum))
                podIndent = 0
        else:
            rec0 = re.sub(r"^=item \**", "* " * max(podIndent, 1), rec0)
            for i0, pc in enumerate(podChanges):
                rec0 = re.sub(pc[0], pc[1], rec0)
            print(rec0)

    elif (re.match(r"=pod", rec0)):                     # start perldoc
        print('descr = """')
        inpod = 1
        podIndent = 0

    elif (re.match(r"(my\s+)?\$\w+\s*=\s*GetOptions\s*\(", rec0)): # GetOpt::Long
        handleGetOpt(ifh0)

    elif (args.getOptVar and
          re.match(r"\s*(my\s+)?[$%]\s*=", rec0)):       # Args for GetOpt::Long
        handleGetOpt(ifh0)

    elif (re.match(r'\s*"[^"]*";?\s*(#.*)?$', rec0)):    # lone "string"
        print(varsInString(rec0))

    elif (re.match(r"\s*#!", rec0)):                     # shebang
        print("#!/usr/bin/env python")
        #print ("# " + str(time.localtime()) +
        print("# " + str(datetime.date.fromtimestamp(time.time())) +
               ": Converted by perl2python, by Steven J. DeRose.")

    elif (re.match(r"\s*#", rec0)):                      # comments
        print(rec0)

    elif (re.match(r"package ", rec0)):                  # indent 'def'?
        print(re.sub(r"package", "class", rec0))
        seenPackage = 1

    else:
        rec0 = rec0.expandtabs(args.tabs)               # normalize tabs
        if (args.verbose > 1): info("Normal: %s" % (rec0))
        com0 = ""                                       # Strip trailing comment
        mat0 = re.search(r'\s*#[^"]*$', rec0)
        if (mat0):
            com0 = rec0[mat0.start():]
            rec0 = rec0[0:mat0.start()]

        rec1 = rec0
        nChangesApplied = 0
        for i0 in range(nChanges):                      # do the changes
            if (args.trace):
                info("    " + str(i0) + ": |" + changes[i0][2].pattern +
                      "|" + changes[i0][1] + "|")
            try:
                rec2 = re.sub(changes[i0][2], changes[i0][1], rec1)
                if (rec2 != rec1): nChangesApplied += 1
            except re.error as X:
                if (str(X) != "unmatched group"):
                    fatal("#### Exception at line " + str(recnum) + "\n" +
                          "    record: " + rec0 + "\n" +
                          "    lhs: " + changes[i0][0] + "\n" +
                          "    rhs: " + changes[i0][1] + "\n" +
                          "    Exception is: " + str(X))
            if (args.verbose and notableDiff(rec1, rec2)):
                info("%4d: <'%s'\n  (%s%3d)    >'%s'" % (recnum, rec1, delta, i0, rec2))
            rec1 = rec2
        rec0 = rec1

        if (args.specialVars):
            for i0, c0 in enumerate(specialVarChanges):
                rec0 = re.sub(c0[0], c0[1], rec0)

        if (com0):
            rec0 = rec0.rstrip() + "  " + com0
        # For 'def' lines, join up with arg dcl, presume my ($x,...) = @_
        if (re.match(r"(  )?def ", rec0)):
            print(rec0, end="")
        elif (re.match(r"\s*;\s*\n", rec0)):
            print(rec0)
        else:
            print(rec0)
    # endif
    rec0 = ifh0.readline()
    recnum = recnum + 1

ifh0.close()
