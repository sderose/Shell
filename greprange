#!/usr/bin/perl -w
#
# greprange: Extract text starting at each line with a hit,
# and continuing until some other kind of hit.
#
# 2008-02-01: Written by Steven J. DeRose.
# 2008-02-11 sjd: Add -c, -i, --iend, --istart, -n, -v(invert-match).
#     Start multi-file support, -h -H -o.
# 2015-08-20: Clean up.
#
# To do:
#     Maybe just integrate into 'body' or 'grepData'?
#     -b (byte-offset), -u (unix-byte-offsets) (strips CR).
#     Pull in code for various other options from grepData.
#     

use strict;
use Getopt::Long;

our $VERSION_DATE = "2015-08-20";

my $count 		     = 0;
my $iEnd 		     = 0;
my $ignoreCase 	     = 0;
my $invert 		     = 0;
my $iStart 		     = 0;
my $label 		     = "";
my $lineNumber 	     = 0;
my $maxRanges 	     = 0;
my $onlyMatching     = 0;
my $quiet 		     = 0;
my $start 		     = "";
my $suppress 	     = 0;
my $end 	         = "";
my $verbose 	     = 0;
my $withFilename     = 0;


# Process options
#
Getopt::Long::Configure ("ignore_case");
my $result = GetOptions(
	"count!"            => \$count,
	"end=s"             => \$end, 
	"h|help|?"          => sub { system "perldoc $0"; exit; },
    "with-filename!"    => \$withFilename,
    "no-filename"       => sub { $withFilename = 0; },
	"i|ignore-case!"    => \$ignoreCase,
	"iend!"             => \$iEnd,
	"istart!"           => \$iStart,
	"label=s"           => \$label,
	"n|line-number!"    => \$lineNumber,
	"max=i"             => \$maxRanges,
	"o|only-matching!"  => \$onlyMatching,
	"q|quiet!"          => \$quiet,
	"start=s"           => \$start,
	"suppress!"         => \$suppress,
	"verbose+"          => \$verbose,
	"v|invert-match!"   => \$invert,
    "version"           => sub {
		die "Version of $VERSION_DATE, by Steven J. DeRose.\n";
	},
	"y"                 => sub { $ignoreCase = 1; }
	);

($result) || die "Bad options.\n";


# Validate and default options
#
my $fh;
my $file = shift;
if ($file) {
	(-f $file) || die "Couldn't find file '$file'.\n";
	($verbose) && warn "Opening '$file'.\n";
	(open $fh, "<$file") || die "Failed to open '$file'.\n";
}
else {
	($verbose) && warn "Opening STDIN...\n";
	(open $fh, "<&STDIN") || die "Failed to open STDIN.\n";
}

($start) || ($end) ||
	die "Must specify at least --start or --end expression.\n";

(@ARGV > 1) &&
	warn "Only set up for one file at a time so far.\n";

my $ignoreFlag = ($ignoreCase) ? "i":"";


###############################################################################
# Main
#
my $nFiles = 0;
my $nFound = 0;
my $totLines = 0;

while (my $f = shift) {
	if (! -f $f) {
		($suppress) || warn "Could not find file '$f'.\n";
		next;
	}
	$nFiles++;
	my $inRange = 0;
	my $lnum = 0;
    while(my $rec = <$fh>) {
        $lnum++;
		$totLines++;
        if ($inRange) {
            if ($rec =~ m/$end/ ||
				($ignoreFlag && $rec =~ m/$end/i)) {
				if (!$count && !$iEnd) {
					print "" . ($lineNumber ? "$lnum:":"") . $rec;
				}
                $inRange = 0;
                if ($maxRanges > 0 && $nFound >= $maxRanges) { last; }
            }
			else {
				if (!$count) { print "" . ($lineNumber ? "$lnum:":"") . $rec; }
			}
        }
        else {
            if ($rec =~ m/$start/ ||
				($ignoreFlag && $rec =~ m/$start/i)) {
                 $inRange = 1;
                 $nFound++;
                 if (!$count && !$iStart) {
					 print "" . ($lineNumber ? "$lnum:":"") . $rec;
				 }
            }
        }
	} # EOF
} # per file

($quiet) ||	warn
    "Done, $nFound hits found, $totLines records searched, $nFiles files.\n";
exit;


###############################################################################

=pod

=head1 Usage

greprange [options] [files]

Extract ranges of lines from a file(s), where the range starts and ends
are indicated by (Perl) regular expressions.

For example:

    greprange --start '<abstract>' --end '</abstract>'

would pull out all the lines constituting an XML 'abstract' element(s).


=head1 Options

(most are like for 'grep'):

=over

=item * B<--count>

Just count hits, don't display them.

=item * B<--end> I<'expr'>

Expression to end at.

=item * B<--headings>

Prefix filename(s) to matched lines.

=item * B<-i>

Ignore case.

=item * B<--iend>

Include the matching 'end' line itself.

=item * B<--invert-match> (or -v) 

Print lines *outside* of matched ranges.

=item * B<--istart>

Include the matching 'start' line itself.

=item * B<--label> I<l>

Display I<l> as the 'filename' for hits on STDIN.

=item * B<--line-number> (or -n)

Prefix displayed lines with line numbers.

=item * B<--start> I<expr>

Expression to start at.

=item * B<--max> I<n>

Only find this many ranges.

=item * B<--only-matching> or B<-o>

Show only the in-range part of the start/end lines.

=item * B<-q> or B<--quiet>

Suppress most messages.

=item * B<-s>

Suppress messages about missing files.

=item * B<--verbose>

Add more detailed messages.

=item * B<--version>

Display version info and exit.

=back


=head1 Related commands

You can do this with a bit of C<awk> if you remember how.


=head1 Known bugs and limitations

I<-h> and I<-o> are not finished. 

There are no 'grep'-like options for:
    context: I<-A> I<-B> I<-C>; 
    regex types: I<-E> I<-e> I<-F> I<-G> I<-w> I<-x>;
    unusual file options: I<-a> I<-d> I<-D> I<-I> I<-U>; 
    other: I<-f> I<-l> I<-L> I<-r> and I<-z>.


=head1 Ownership

This work by Steven J. DeRose is licensed under a Creative Commons 
Attribution-Share Alike 3.0 Unported License. For further information on
this license, see L<http://creativecommons.org/licenses/by-sa/3.0/>.

For the most recent version, see L<http://www.derose.net/steve/utilities/>.

=cut
