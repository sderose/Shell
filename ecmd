#!/usr/bin/perl -w
#
# ecmd: Find a command/alias/shell function/etc., and edit it.
# 2012-05-08: Written by Steven J. DeRose.
#
use strict;
use Getopt::Long;

our %metadata = (
    'title'        => "ecmd",
    'description'  => "Find a command/alias/shell function/etc., and edit it.",
    'rightsHolder' => "Steven J. DeRose",
    'creator'      => "http://viaf.org/viaf/50334488",
    'type'         => "http://purl.org/dc/dcmitype/Software",
    'language'     => "Perl 5.18",
    'created'      => "2012-05-08",
    'modified'     => "2022-08-18",
    'publisher'    => "http://github.com/sderose",
    'license'      => "https://creativecommons.org/licenses/by-sa/3.0/"
);
our $VERSION_DATE = $metadata{'modified'};


=pod


=head1 Usage

ecmd [options] commandName

Find where I<commandName> is defined, and edit its definition (if feasible).
Binaries will not be opened. Scripts will be opened with your \$EDITOR.
For aliases and shell functions, the file where they are defined (if any)
should open at the right line.

To just display the location without opening \$EDITOR, set I<--noedit>.

Commands are identified via the C<whence> and/or C<type> commands,
which are run under a fresh interactive bash shell. This means that your usual
shell profiles should be run, however, anything you manually defined or added to \$PATH
may be missed. If C<whence> and C<type> fail, the directories in \$PATH will
be searched. 

For aliases and shell functions, the usual shell setup files
are also searched. When a defining file is found, it is searched for
the definition, and your \$EDITOR should open to the correct line.

To search extra files that define aliases or shell functions (perhaps that are
sourced from .bash_profile, .zprofile, etc...), list them in
environment variable C<\$ECMDPATH>, separated by colons like with \$PATH.
Or specify them with the (repeatable) I<--addProfile> option.

Use I<-v> to see a list of all the places to be searched.

This script was originally written for use with C<bash>. It might still have
problems in zsh (let me know if you hit any).


=head1 Options

(prefix 'no' to negate where applicable)

=over

=item * B<--addProfile> I<path>

Add the file at I<path> to (the end of) the list of places to look for
definitions of aliases and shell functions. Repeatable.
The usual suspects, such as F<.bash_profile>, F<.bashrc>, etc.
are already covered (use C<-v> for a list).
You can also/instead set environment variable C<\$ECMDPATH>.

=item * B<--edit>

If not binary, open the file defining the requested item, using \$EDITOR.
For aliases and shell functions, open it to the start of the actual definition.
Binaries are not opened, though their path is reported.
Use I<--no-edit> to skip opening the found file.

=item * B<--interactive>

When checking what kind of thing the command is,
run C<whence> and C<type> in an interactive shell (default).

=item * B<--login>

When checking what kind of thing the command is,
run C<whence> and C<type> in a login shell.

=item * B<-q> OR B<--quiet>

Suppress most messages.

=item * B<-v> OR B<--verbose>

Add more messages.

=item * B<--version>

Show version info and exit.

=back


=head1 Known Bugs and Limitations

Does not check all possible places that an alias or shell function
could be defined. In particular, does not consider files invoked by a
setup file, or cases where a setup file defines different things in different
situations. However, you can add such files by adding them in environment variable
C<$ECMDPATH> or option C<--addProfile>.

Does not expand C<\$BASH_ENV> or C<\$ENV> before trying it as a path.

Assumes your C<\$EDITOR> has a I<+n> option to take you to line number I<n>
(this is used to get you right to the definition of an alias or shell function).
C<emacs>, C<vi>, C<pico>, C<gedit>, C<bbedit>, and C<xedit> are all ok.
It does know a few specific exceptions, such as that C<SublimeText> uses C<:n> instead.
C<kompozer> doesn't seem to have a comparable option (but see
L<http://sourceforge.net/tracker/index.php?func=detail&aid=2941487&group_id=170132&atid=853125>).

C<whence> and C<type> return stereotyped responses for each kind of command.
If your local versions return significantly different forms,
you will need to adjust this script accordingly. It currently assumes:

    xxx is aliased to `xxx -i'
    xxx is a shell keyword
    xxx is a shell builtin
    xxx is a function
    xxx is hashed (/home/mluther/bin/xxx)
    xxx is /usr/bin/xxx
    bash: type: xxx: not found (or in zsh, just "xxx not found")


=head1 Related commands

C<bash>, C<zsh>, C<type>, C<which>, C<shopt>.

L<https://unix.stackexchange.com/questions/322459/is-it-possible-to-check-where-an-alias-was-defined>
provides some useful information on how to locate aliases and such.


=head2 Auto-completion

*nix variants differ in how you configure auto-completion of commands, so you may have
to fiddle around a bit to get that working so you can use C<ecmd> without typing
the entire name for the target command.

To enable auto-completion with this script in C<bash> use

    complete -F _command ecmd

On Mac OS X you may need to use the C<zsh> equivalent first,
or install bash_completion, for example as:

    sudo port install bash-completion

bash-completion >=2.0 requires bash >=4.1. Also, add to your .bash_profile:

  if [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then
      . /opt/local/etc/profile.d/bash_completion.sh
  fi

See L<http://superuser.com/questions/288438/bash-completion-for-commands-in-mac-os>.

=head2 Categories of commands

The categories of items checked are those distinguished by the C<whence> and C<type>
commands. Commands are found by Bash in this order (same in zsh?):

  aliases (can override shell keywords and/or shell builtins)
  shell keywords
  shell builtins
  POSIX special builtins
  shell functions (B<cannot> define one overriding a shell keyword)
  files (per \$PATH), including:
      hashed executables
      other executables

This script declines to edit executable files that are binary.

The POSIX special builtins only apply in POSIX mode. They are:

    break, :, ., continue, eval, exec, exit, export, readonly, return, set,
shift, trap, unset.

A nice page on bash's startup and other behavior is:
L<http://wiki.bash-hackers.org/scripting/bashbehaviour>.


=head1 To do

Add doc on how to set up autocompletion for this in zsh.

Be able to find the thing that an alias is aliased to and edit C<it>.


=head1 History

=over

=item * 2012-05-08f: Written by Steven J. DeRose.

=item * 2012-11-02: Find specific line for aliases and shell functions.
Check whole set of bash profile-ish files. Warn on non-bash.
Force 'type' in interactive shell so functions/aliases are visible.

=item * 2012-12-06: Add doc on order things are found. Add --noninteractive.
Make -q and -v do something.

=item * 2013-04-08: Start adding checks of files sourced from profiles.

=item * 2013-08-27: Fix emacs line-seek arg for BSD/Mac.

=item * 2014-12-30: Try to get working for shell functions. Add -l.

=item * 2015-02-05: Fix bug where it dropped output from 'type' command.
Add --addProfile.

=item * 2020-04-15: New layout. Add $ECMDPATH support.

=item * 2021-01-21: Map 'open to line number' as needed per EDITOR.

=item * 2021-03-10: Only add line arg if >1. Switch '+n' to ':n' for sublimeText.=======

=item * 2021-11-17: Clean up, nuke useless error messages, start C<mapType>().

=item * 2021-12-15ff: Rewrite findType() to use `zsh -c "type -w..."`, much cleaner.

=item * 2022-08-18: Refactor and clean up searching. Make use 'whence', which
hands back path info more often.

=back


=head1 Rights

Copyright 2012-05-08 by Steven J. DeRose. This work is licensed under a
Creative Commons Attribution-Share-alike 3.0 unported license.
See L<http://creativecommons.org/licenses/by-sa/3.0> for more information.

For the most recent version, see L<http://www.derose.net/steve/utilities/>
or L<http://github.com/sderose>.


=cut


###############################################################################
# Options
#
my @addProfile    = ();
my $edit          = 1;
my $interactive   = 1;
my $login         = 1;
my $quiet         = 0;
my $verbose       = 0;

my %getoptHash = (
    "addProfile=s"    => \@addProfile,
    "edit!"           => \$edit,
    "h|help"          => sub { system "perldoc $0"; exit; },
    "interactive!"    => \$interactive,
    "login!"          => \$login,
    "q|quiet!"        => \$quiet,
    "v|verbose+"      => \$verbose,
    "version"         => sub {
        die "Version of $VERSION_DATE, by Steven J. DeRose.\n";
    },
);
Getopt::Long::Configure ("ignore_case");
(GetOptions(%getoptHash)) || die "Bad options.\n";

($ARGV[0]) || die "No command name specified.\n";


###############################################################################
# Globals
#
my @allPaths;      # Paths to other scripts, from $ECMD_PATH and --addProfile
my @profilePaths;  # Paths to standard bash and zsh .-files

my %lineSeekPrefix = (  # lookups are via lowercased name
    'emacs'  		=> '+',
    'vi'	    	=> '+',
    'pico'		    => '+',
    'gedit'         => '+',
    'bbedit'        => '+',
    'xedit'         => '+',
    'sublimetext'   => ':',
    'kompozer'      => '',  # not supported?
);

sub lineSeekOption {
    my ($editorName, $fndLine) = @_;
    (!$fndLine) && return '';
    (defined $lineSeekPrefix{lc($editorName)}) || return '';
    return $lineSeekPrefix{lc($editorName)} . $fndLine;
}

sub fmtList {
    my (@theList) = @_;
    return "\n    " . join("\n    ", @theList) | "\n";
}

my %typeNames = (
    "ALIAS"    => "ALIAS",
    "BUILTIN"  => "BUILTIN",
    "COMMAND"  => "COMMAND",
    "FUNCTION" => "FUNCTION",
    "HASHED"   => "HASHED",
    "NONE"     => "NOTFOUND",
    "KEYWORD"  => "KEYWORD",
    "BINARY"   => "BINARY",
);

# See what 'type' says about the command. But inside Perl we don't have \$PATH
# or all the aliases, etc. user may have.
# Force 'type' to run via an interactive shell, so profiles are in effect.
#
sub findType {
    my ($login, $interactive, $cmd) = @_;
    
    my ($typeEnum, $path) = tryWhence($login, $interactive, $cmd);
    
    if ($typeEnum eq "NOTFOUND") {
        ($typeEnum, $path) = tryType($login, $interactive, $cmd);
    }
    # Try manual search in the usual suspects
    #if ($typeEnum eq "NOTFOUND") {
    #    ($typeEnum, $path) = trySearch($login, $interactive, $cmd);
    #}          
    defined ($typeNames{$typeEnum}) || die
        "Unexpected type '$typeEnum'.\n";
    ($verbose) && print 
        "Type: '$typeEnum'. Path: '$path'\n";
    return $typeEnum, $path;
}

sub tryWhence {
    # Sample 'whence' responses (MacOS):
    #     ecmd is [path]
    #     gitsubs is a shell function from [path]
    #     ll is an alias for ls -o
    #     zerg not found
    #
    my ($login, $interactive, $cmd) = @_;
    my $shellCmd = "whence '$cmd'";
    my $tail = runShellCommandInRealEnv($login, $interactive, $shellCmd, 1);
    ($verbose > 1) && warn "'whence' got: $tail\n";
    if ($tail =~ m/(.*?) is a shell function from (.*)/) {
        return "FUNCTION", $2;
    }
    if ($tail =~ m/(.*?) is an alias for (.*)/) {
        return "ALIAS", "";
    }
    if ($tail =~ m/(.*?) not found/) {
        return "NOTFOUND", "";
    }
    if ($tail =~ m/(.*?) is (.*)/) {
        if (-B $2) { return "BINARY", $2; }
        return "COMMAND", $2;
    }
    warn "Cannot understand 'whence' response: $tail.\n";
    return "NOTFOUND", "";
}

sub tryType {
    # Sample 'whtypeence' responses (MacOS):
    #     ecmd is [path]
    #     gitsubs is a shell function from [path]
    #     ll is an alias for ls -o
    #     zerg not found
    #
    my ($login, $interactive, $cmd) = @_;
    my $shellCmd = "type -w '$cmd'";
    my $tail = runShellCommandInRealEnv($login, $interactive, $shellCmd, 1);
    ($verbose > 1) && warn "'type' got tail: $tail\n";
    if ($tail =~ m/(.*?) is a shell function from (.*)/) {
        return "FUNCTION", $2;
    }
    if ($tail =~ m/(.*?) is an alias for (.*)/) {
        return "ALIAS", "";
    }
    if ($tail =~ m/(.*?) not found/) {
        return "NOTFOUND", "";
    }
    if ($tail =~ m/(.*?) is (.*)/) {
        if (-B $2) { return "BINARY", $2; }
        return "COMMAND", $2;
    }
    warn "Cannot understand 'whence' response: $tail.\n";
    return "NOTFOUND", "";
}

# Run a command via a shell, and grab the output. This is a bit of a pain
# because you need to duplicate the user's environment in a new shell, including
# aliases and other setup. Also, starting a shell may cause other output.
#
sub runShellCommandInRealEnv {
    my ($login, $interactive, $shellCmd, $nTail) = @_;
    my $toRun = "";
    my $tmpFile = "/tmp/ecmd.tmp";
    if (1) {  # zsh
        my $inter =  $interactive ? "-i":"";
        my $login = $login ? "-l":"";
        # grab just last line, since launching zsh may cause other output.
        my $typeCmd = "$shellCmd | tail -n $nTail >$tmpFile";
        $toRun = "zsh $inter $login -c '$typeCmd' 2>/dev/null";
    }
    else {  # bash
        $toRun = "type -w '$shellCmd' 2>/dev/null >$tmpFile";
    }
    ($verbose > 1) && warn "Running: $toRun\n";
    my $cruft = `$toRun`;
    ($verbose > 1) && warn "### Result: <<<\n$cruft>>>\n";

    my $tailLines = `cat $tmpFile`;
    ($tailLines) || die "No output from '$toRun'.\n";
    chomp $tailLines;
    ($verbose > 1) && warn "### Last $nTail lines: <<<\n    $tailLines>>>\n";
    return $tailLines;
}

# Display the command, what it was found to be, and if the definition was found,
# the file and optional line number (latter for shell functions and aliases).
#
sub reportType {
    my ($theCmdName, $typ, $file, $line) = @_;
    if ($quiet) { return; }
    my $msg = sprintf("'%s' is %s %s. ", $theCmdName, getArticle($typ), $typ);
    if ($file) {
        $msg .= sprintf("Found at %s (%sopening).\n",
            $file, $typ eq "binary" ? "not " : "");
        #if ($line) { $msg .= ", line $line"; }
    }
    print $msg;
}

sub getArticle {
    my ($word) = @_;
    # Haccidents ardly hever appen.
    return ($word =~ m/^[aeiouh]/) ? "an":"a";
}

###############################################################################
# Places to look for startup/profile files
#
# The bash sequence depends on:
#     Bash options --login, --noprofile, --rcfile, --norc, -c, -i
#     Whether the shell is interactive and/or login
#     Whether the shell was invoked as 'bash' or 'sh'
#     Environment variable $BASH_ENV or $ENV
#     Whether effective user/group id != real user/group id AND -p not set.
# Of course, the environment could depend on arbitrary logic in profiles....
#
# Fill in @profilePaths and @allPAths.
#
sub setupPaths {
    @profilePaths = getProfilePaths();

    my $ep = $ENV{"ECMDPATH"};
    my @ecmdPaths = ();
    if ($ep) {
        @ecmdPaths = split /:/, $ENV{"ECMDPATH"};
    }
    ($verbose) && warn 
        "\n\$ECMDPATH gives:" . fmtList(@ecmdPaths);

    @allPaths = (@profilePaths, @ecmdPaths);
    ($verbose) && warn sprintf(
        "profilePaths |%d|, allPaths |%d|\n", scalar @profilePaths, scalar @allPaths);

    ($verbose) && warn 
        "\n\@profilePaths for alias/function definitions: " . fmtList(@profilePaths);

    my $sjdDir = $ENV{"sjdUtilsDir"};
    if ($sjdDir && -d "$sjdDir/Public") {
        ($verbose) && warn 
            "Adding sjd Utils from '$sjdDir/Public'.\n";
        my $bset = "$sjdDir/Public/*";
        push @allPaths, $bset;
    }
}

sub getProfilePaths {
    my $profile = "$ENV{HOME}/.bash_profile";

    # Test current shell first, and just add the needed ones? Or is it better
    # to try all, so we can report other places the user may want?
    #
    my @profilePaths = (
        "$ENV{HOME}/.zshenv",
        "$ENV{HOME}/.zzprofile",
        "$ENV{HOME}/.zshenv",

        # For bash (
        # INTERACTIVE NON-LOGIN (or non-interactive with --login):
        "/etc/profile",                # 1: system-wide startup
        "$ENV{HOME}/.bash_profile",    # 2a: personal init
        "$ENV{HOME}/.bash_login",      # 2b: personal init
        "$ENV{HOME}/.profile",         # 2c: personal init
        #"$ENV{HOME}/bin/bash_profile", # 2d: Author's convention
        # INTERACTIVE NON-LOGIN:
        "/etc/bash.bashrc",            # system-wide init
        "$ENV{HOME}/.bashrc",          # personal init
        "$ENV{HOME}/bin/bash_profile", # I keep stuff here so not invisible.

    );
    ($verbose>1) && warn
        "Initial profile paths:" . fmtList(@profilePaths);

    # NON-INTERACTIVE (must be expanded; don't use $PATH)
    if (defined $ENV{BASH_ENV}) {
        ($verbose) && warn "Adding path: '$ENV{BASH_ENV}'\n";
        push @profilePaths, $ENV{BASH_ENV};
    }
    if (defined $ENV{ENV}) { # only if 'sh'
        push @profilePaths, $ENV{ENV};
    }
    if (@addProfile) {
        push @profilePaths, @addProfile;
    }
    return @profilePaths;
}


###############################################################################
# Functions to find specific definitions within a file (just use grep).
#
my %functionRegexes = (
    "Python" =>     "^\\s*def\\s+\\w+\\s*\(",
    "Perl" =>       "^\\s*sub\\s+\\w+\\s*{",
    "C" =>          "^\\s*(\\w+)\\s*\\*?(\\w+)\\(",
);

sub findProgFunctionDef {
    my ($cmd, $path) = @_;
    my @hitLocs = ();
    for my $lg (keys(%functionRegexes)) {
        push (@hitLocs, findAll($functionRegexes{$lg}, $path));
    }
    return @hitLocs;
}

sub findFunctionDef {
    my ($funcName, $path) = @_;
    my @hitLocs = findAll("^ *$funcName()\\s{", $path);
    return @hitLocs;
}

sub findAliasDef {
    my ($cmd, $path) = @_;
    my @hitLocs = findAll("^\\s*alias\\s+$cmd+=", $path);
    return @hitLocs;
}

# Search for a given regex in a path somebody else found already,
# or if that's nil then search all the files in passed lists.
# Return all the hits found in the first file that has any,
# or if $doAllFiles is set then all the hits in all the files.
# Returns: a list of path:lineNum strings (as from grep).
#
sub findAll {
    my ($regex, $path, $doAllFiles) = @_;
    if ($path) {
        ($verbose) && print "findAll: Searching in: $path.\n";
        return getAllLines($path, $regex);
    }
    ($verbose) && printf("findAll: Searching in %d files.\n",
        scalar(@allPaths) + scalar(@profilePaths));
    my @allHitLocs = ();
    for my $curPath (@allPaths) {
        my @hitLocs = getAllLines($curPath, $regex);
        if (scalar @hitLocs == 0) { next; }
        push(@allHitLocs, @hitLocs);
        if (! $doAllFiles) { last; }
    }
    for my $curPath (@profilePaths) {
        my @hitLocs = getAllLines($curPath, $regex);
        if (scalar @hitLocs == 0) { next; }
        push(@allHitLocs, @hitLocs);
        if (! $doAllFiles) { last; }
    }
    return(\@allHitLocs);
}

# Return array of lines matching the regex.
#
sub getAllLines {
    my ($file, $regex) = @_;
    (-r $file) || return("");
    ($verbose) && warn "getAllLines: grepping in '$file'.\n";
    my @hitLocs = ();
    my $buf = `grep -r -n '$regex' $file`;
    ($verbose) && warn "$file:\n    ++>$buf\n";
    if ($buf =~ m/^(\d+):/) {
        for my $line (split(/\n/, $buf)) {
            push @hitLocs, $line =~ s/(^[^:]*:[^:]*):.*/$1/;
        }
    }
    return(@hitLocs);
}

sub notFoundMsg {
    my ($cmdName, $type) = @_;
    reportType($cmdName, $type, sprintf(
        ", not found in any of %d profiles, %d other files (see \$ECMD_PATH).",
        scalar @profilePaths, scalar @allPaths));
}


###############################################################################
# Main
#
my $cmd = $ARGV[0];
my $fndLine = 1;

# Warn about environment issues
#
my $shell = $ENV{SHELL} || "";
($shell ne "/bin/zsh" && $verbose) && print
    "Your shell is $ENV{SHELL}, not /bin/zsh. This may not work....\n";

setupPaths();

# This only sets $path for some things (like, not aliases)
my ($typ, $path) = findType($login, $interactive, $cmd);

# Check for alias/shell function first, in case they overrode a name.
#
if ($typ eq "FUNCTION") {
    my @hitLocs = findAll("^ *$cmd()\\s{", $path);
    if (scalar @hitLocs) {
        for my $hitLoc (@hitLocs) {
            $hitLoc =~ s/.*://;
            reportType($cmd, "FUNCTION", $path, $hitLoc);
        }
    }
    else {
        notFoundMsg($cmd, "FUNCTION");
    }
}
elsif ($typ eq "ALIAS") {
    my @hitLocs = findAll("^\\s*alias\\s+$cmd+=", $path);
    if (scalar @hitLocs) {
        for my $hitLoc (@hitLocs) {
            $hitLoc =~ s/.*://;
            reportType($cmd, "ALIAS", $path, $hitLoc);
        }
    }
    else {
        notFoundMsg($cmd, "ALIAS");
    }
}
elsif ($typ eq "BINARY") {
    reportType($cmd, "BINARY", $path);
}
elsif ($typ eq "BUILTIN") {
    reportType($cmd, "BUILTIN", $path);
}
elsif ($typ eq "COMMAND") {
    reportType($cmd, "non-binary COMMAND", $path);
}
elsif ($typ eq "HASHED") {
    reportType($cmd, "HASHED", $path);
}
elsif ($typ eq "KEYWORD") {
    reportType($cmd, "reserved shell keyword", "(nothing to edit)");
}
elsif ($typ eq "NONE") {
    # Could still be alias/shell function that script doesn't see?
    #
    ($verbose) && warn "Could not identify '$cmd'.\n";
}
else {
    ($quiet) || warn "Unrecognized response from '$cmd':\n$typ\n";
}

#warn "Item definition found at '$path'\n";

# If we found it, go edit it.
#
if ($path && $typ ne "BINARY" && $edit) {
    ($quiet) || printf("  Last modified %3.1f days ago.\n", -M($path));
    if (defined $ENV{EDITOR}) {
        my $edcmd = "$ENV{EDITOR} " . lineSeekOption($fndLine) . " $path";
        ($verbose) && warn "Editing with command: $edcmd\n";
        system($edcmd) && warn("Failed.\n");
    }
    else {
        warn "Environment variable \$EDITOR is not set. But file is at:\n    $path\n";
    }
}
