#!/usr/bin/perl -w
#
# ecmd: Find a command/alias/shell function/etc., and edit it.
# 2012-05-08: Written by Steven J. DeRose.
#
use strict;
use Getopt::Long;

our %metadata = (
    'title'        => "ecmd",
    'description'  => "Find a command/alias/shell function/etc., and edit it.",
    'rightsHolder' => "Steven J. DeRose",
    'creator'      => "http://viaf.org/viaf/50334488",
    'type'         => "http://purl.org/dc/dcmitype/Software",
    'language'     => "Perl 5.18",
    'created'      => "2012-05-08",
    'modified'     => "2021-12-15ff",
    'publisher'    => "http://github.com/sderose",
    'license'      => "https://creativecommons.org/licenses/by-sa/3.0/"
);
our $VERSION_DATE = $metadata{'modified'};

=pod

=head1 Usage

ecmd [options] commandName

Find where I<commandName> is defined, and edit its definition (if feasible).
Binaries will not be opened. Scripts will be opened with your \$EDITOR.
For aliases and shell functions, the file where they are defined (if any)
should open at the right line.

Commands are identified via the C<type> command, which is run under a fresh
interactive bash shell (running it straight from Perl's environment would miss a lot).

This script is mainly meant for use with C<bash>. To recognize shell
functions and aliases, it needs to see the environment with them defined,
so it should be run as an `interactive` and possibly as
a `login` shell (see L<Options> below).

It knows to look in the "usual" places, but you can add other places to
check (see next section).

=head2 Where this script (and bash) look for commands

Aliases and shell function definitions are sought among the various bash and zsh
profile/startup files (via invoking a shell to run C<type>).

To search extra files that define aliases or shell functions (perhaps that are
sourced from .bash_profile, .bashrc,...), list them in
environment variable C<ECMDPATH>, separated by colons like \$PATH, etc.
Or specify them with the (repeatable) I<--addProfile> option.

Use I<-v> to see a list of all the places to be searched.


=head1 Options

(prefix 'no' to negate where applicable)

=over

=item * B<--addProfile> I<path>

Add the file at I<path> to (the end of) the list of places to look for
definitions of aliases and shell functions. Repeatable.
The usual suspects, such as F<.bash_profile>, F<.bashrc>, etc.
are already covered (use C<-v> for a list).
You can also/instead set environment variable C<$ECMDPATH>.

=item * B<--edit>

If appropriate, open the file defining the requested item, using \$EDITOR.
For aliases and shell functions, open it to the start of the actual definition.
Binaries are not opened, though their path is reported.
Use I<--no-edit> to skip opening the found file.

=item * B<--interactive>

When checking what kind of thing the command is,
run C<type> in an interactive Bash shell (default).

=item * B<--login>

When checking what kind of thing the command is,
run C<type> in a Bash login shell.

=item * B<-q> OR B<--quiet>

Suppress most messages.

=item * B<-v> OR B<--verbose>

Add more messages.

=item * B<--version>

Show version info and exit.

=back


=head1 Known Bugs and Limitations

Does not check all possible places that an alias or shell function
could be defined. In particular, does not consider files invoked by a
setup file, or cases where a setup file defines different things in different
situations. However, you can add such files by setting environment variable
C<$ECMDPATH> or option C<--addProfile>.

Does not expand C<$BASH_ENV> or C<$ENV> before trying it as a path.

Assumes your C<$EDITOR> has a I<+n> option to take you to line number I<n>
(this is used to get you right to the definition of an alias or shell function).
C<emacs>, C<vi>, C<pico>, C<gedit>, C<bbedit>, and C<xedit> are all ok.
C<SublimeText> uses C<:n> instead.
C<kompozer> isn't (but see
L<http://sourceforge.net/tracker/index.php?func=detail&aid=2941487&group_id=170132&atid=853125>).

*nix variants differ in how you configure auto-completion of commands, so you may have
to fiddle around a bit to get that working.


=head1 Related commands

C<bash>, C<type>, C<which>, C<type>, C<shopt>.


=head1 Notes

When an instance of C<bash> starts up, if it's a B<login> shell, it runs F</etc/profile>. Then
it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile,
in  that order, and reads and executes commands from the first one readable.
C<ecmd> checks all those places.

=head2 Auto-completion

To enable auto-completion with this script in C<bash> use

    complete -F _command ecmd

On Mac OS X, you may need to do the C<zsh> equivalent first,
or install bash_completion, for example as:

    sudo port install bash-completion

bash-completion >=2.0 requires bash >=4.1. Also, add to your .bash_profile:

  if [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then
      . /opt/local/etc/profile.d/bash_completion.sh
  fi

See L<http://superuser.com/questions/288438/bash-completion-for-commands-in-mac-os>.

=head2 Categories of commands

The categories of items checked are those distinguished by the C<type>
command. Commands are found by Bash in this order:

  aliases (can override shell keywords and/or shell builtins)
  shell keywords
  shell builtins
  POSIX special builtins
  shell functions (B<cannot> define one overriding a shell keyword)
  files (per $PATH), including:
      hashed executables
      other executables

This script declines to edit executable files that are binary.

The POSIX special builtins only apply in POSIX mode. They are:

    break, :, ., continue, eval, exec, exit, export, readonly, return, set,
shift, trap, unset.

=head2 bash configuration

This script runs C<type> in
a separate I<interactive> C<bash> shell, so it identifies the specified command
name presuming that context (see I<--interactive> and I<--login>).

Many factors affect how C<bash> ends up configured, and thus what
a particular command name does. For example:

=over

=item * Whether you're running C<bash> or a different shell altogether

=item * Whether C<bash> is running as a login, interactive, or non-interactive shell

=item * Whether C<bash> is in C<sh> compatibility, C<restricted>,
or I<POSIX> compatibility mode

=item * Which of these setup files are in effect:
    F</etc/profile>
    F<$HOME/.bash_profile>
    F<$HOME/.bash_login>
    F<$HOME/.profile>
    F</etc/bash.bashrc>
    F<$HOME/.bashrc>

=item * Other files sourced by those files (but see I<--addProfile>)

=item * Logic implemented in setup files

=item * Changes you've done manually

=back

A nice page on bash's startup and other behavior is:
L<http://wiki.bash-hackers.org/scripting/bashbehaviour>.


=head1 To do


=head1 History

=over

=item * 2012-05-08f: Written by Steven J. DeRose.

=item * 2012-11-02: Find specific line for aliases and shell functions.
Check whole set of bash profile-ish files. Warn on non-bash.
Force 'type' in interactive shell so functions/aliases are visible.

=item * 2012-12-06: Add doc on order things are found. Add --noninteractive.
Make -q and -v do something.

=item * 2013-04-08: Start adding checks of files sourced from profiles.

=item * 2013-08-27: Fix emacs line-seek arg for BSD/Mac.

=item * 2014-12-30: Try to get working for shell functions. Add -l.

=item * 2015-02-05: Fix bug where it dropped output from 'type' command.
Add --addProfile.

=item * 2020-04-15: New layout. Add $ECMDPATH support.

=item * 2021-01-21: Map 'open to line number' as needed per EDITOR.

=item * 2021-03-10: Only add line arg if >1. Switch '+n' to ':n' for sublimeText.=======

=item * 2021-11-17: Clean up, nuke useless error messages, start C<mapType>().

=item * 2021-12-15ff: Rewrite findType() to use `zsh -c "type -w..."`, much cleaner.

=back


=head1 Rights

Copyright 2012-05-08 by Steven J. DeRose. This work is licensed under a
Creative Commons Attribution-Share-alike 3.0 unported license.
See L<http://creativecommons.org/licenses/by-sa/3.0> for more information.

For the most recent version, see L<http://www.derose.net/steve/utilities/>
or L<http://github.com/sderose>.


=cut


###############################################################################
# Options
#
my @addProfile    = ();
my $edit          = 1;
my $interactive   = 1;
my $login         = 1;
my $quiet         = 0;
my $verbose       = 0;

my %getoptHash = (
    "addProfile=s"    => \@addProfile,
    "edit!"           => \$edit,
    "h|help"          => sub { system "perldoc $0"; exit; },
    "interactive!"    => \$interactive,
    "login!"          => \$login,
    "q|quiet!"        => \$quiet,
    "v|verbose+"      => \$verbose,
    "version"         => sub {
        die "Version of $VERSION_DATE, by Steven J. DeRose.\n";
    },
);
Getopt::Long::Configure ("ignore_case");
(GetOptions(%getoptHash)) || die "Bad options.\n";

($ARGV[0]) || die "No command name specified.\n";


###############################################################################
# Globals
#
my @allPaths;      # Paths to other scripts, from $ECMD_PATH and --addProfile
my @profilePaths;  # Paths to standard bash and zsh .-files

my %lineSeekPrefix = (  # lookups are via lowercased name
    'emacs'  		=> '+',
    'vi'	    	=> '+',
    'pico'		    => '+',
    'gedit'         => '+',
    'bbedit'        => '+',
    'xedit'         => '+',
    'sublimetext'   => ':',
    'kompozer'      => '',  # not supported?
);

sub lineSeekOption {
    my ($editorName, $fndLine) = @_;
    (!$fndLine) && return '';
    (defined $lineSeekPrefix{lc($editorName)}) || return '';
    return $lineSeekPrefix{lc($editorName)} . $fndLine;
}


###############################################################################
#
my %typeNames = (
    "alias"    => "ALIAS",
    "builtin"  => "???",
    "command"  => "EXECUTABLE",
    "function" => "FUNCTION",
    "hashed"   => "HASHED",
    "none"     => "NOT-FOUND or FAIL",
    "reserved" => "SHELL-KEYWORD",
    #             # previously NON-EXECUTABLE-FILE
    # "binary" is added below, to distinguish ones not to edit...
);

# See what 'type' says about the command. But inside Perl we don't have \$PATH
#     or all the aliases, etc. user may have.
# Force 'type' to run via an interactive shell, so profiles are in effect.
#
sub findType {
    my ($login, $interactive, $cmd) = @_;
    
    my $shellCmd = "type -w '$cmd'";
    my $typeEnum = my $typeLine = runShellCommandInRealEnv($login, $interactive, $shellCmd, 1);
    chomp $typeEnum;
    $typeEnum =~ s/^.*?:\s*//;
    defined ($typeNames{$typeEnum}) || die
        "Unrecognized type '$typeEnum' returned in '$typeLine' from 'type -w $cmd'.\n";
    
    my $path = "";
    if ($typeEnum eq "command") {
        my $shellCmd2 = "type '$cmd'";
        $path = my $pathLine = runShellCommandInRealEnv($login, $interactive, $shellCmd2, 1);
        chomp $path;
        $path =~ s/^.* is //;
        ($verbose) && warn "path to '$cmd' command is '$path' from response '$pathLine'.\n";
        if (-B $path) { $typeEnum = "binary"; }
    }
    ($verbose) && print "Enum: '$typeEnum'. Path: '$path'\n";
    return $typeEnum, $path;
}

# Run a command via a shell, and grab the output. This is a bit of a pain
# because you need to duplicate the user's environment in a new SHELL, including
# aliases and other setup. Also, starting a shell may cause other output.
#
sub runShellCommandInRealEnv {
    my ($login, $interactive, $shellCmd, $nTail) = @_;
    my $toRun = "";
    my $tmpFile = "/tmp/ecmd.tmp";
    if (1) {  # zsh
        my $inter =  $interactive ? "-i":"";
        my $login = $login ? "-l":"";
        # grab just last line, since launching zsh may cause other output.
        my $typeCmd = "$shellCmd | tail -n $nTail >$tmpFile";
        $toRun = "zsh $inter $login -c '$typeCmd' 2>/dev/null";
    }
    else {  # bash
        $toRun = "type -w '$shellCmd' 2>/dev/null >$tmpFile";
    }
    ($verbose) && warn "### findType(): Running: $toRun\n";
    my $cruft = `$toRun`;
    ($verbose>1) && warn "### Result: <<<\n$cruft>>>\n";

    my $tailLines = `cat $tmpFile`;
    ($tailLines) || die "No output from '$toRun'.\n";
    chomp $tailLines;
    ($verbose) && warn "### Last $nTail line(s) from '$toRun': <<<\n    $tailLines>>>\n";
    return $tailLines;
}

# Display the command, what it was found to be, and if the definition was found,
# the file and optional line number (latter for shell functions and aliases).
#
sub reportType {
    my ($theCmdName, $typ, $file, $line) = @_;
    if ($quiet) { return; }
    my $msg = sprintf("'%s' is a%s %s. ", ($theCmdName, ($typ =~ m/^[aeiouh]/) ? "n ":" "), $typ);
    if ($file) {
        $msg .= sprintf("Found at %s (%sopening).\n", $file, $typ eq "binary" ? "not " : "");
        #if ($line) { $msg .= ", line $line"; }
    }
    print $msg;
}


###############################################################################
# Places to look for startup/profile files
#
# The bash sequence depends on:
#     Bash options --login, --noprofile, --rcfile, --norc, -c, -i
#     Whether the shell is interactive and/or login
#     Whether the shell was invoked as 'bash' or 'sh'
#     Environment variable $BASH_ENV or $ENV
#     Whether effective user/group id != real user/group id AND -p not set.
# Of course, the environment could depend on arbitrary logic in profiles....
#
# Fill in @profilePaths and @allPAths.
#
sub setupPaths {
    @profilePaths = getProfilePaths();

    my $ep = $ENV{"ECMDPATH"};
    my @ecmdPaths = ();
    if ($ep) {
        @ecmdPaths = split /:/, $ENV{"ECMDPATH"};
    }
    ($verbose>1) && warn ("\n\$ECMDPATH gives: [\n    " . join("\n    ", @ecmdPaths) . "]\n");

    @allPaths = (@profilePaths, @ecmdPaths);
    ($verbose>1) && warn sprintf("profilePaths |%d|, allPaths |%d|\n", scalar @profilePaths, scalar @allPaths);

    ($verbose>1) && warn "\n\@profilePaths to be checked for alias/function definitions:\n    " .
        join("\n    ", @profilePaths) . "\n";

    my $sjdDir = $ENV{"sjdUtilsDir"};
    if ($sjdDir && -d "$sjdDir/Public") {
        ($verbose>1) && warn "Adding sjd Utils from '$sjdDir/Public'.\n";
        my $bset = $sjdDir . "/Public/*";
        push @allPaths, $bset;
    }
}

sub getProfilePaths {
    my $profile = "$ENV{HOME}/.bash_profile";

    # Test current shell first?
    #
    my @profilePaths = (
        "$ENV{HOME}/.zshenv",
        "$ENV{HOME}/.zzprofile",
        "$ENV{HOME}/.zshenv",

        # For bash (
        # INTERACTIVE NON-LOGIN (or non-interactive with --login):
        "/etc/profile",                # 1: system-wide startup
        "$ENV{HOME}/.bash_profile",    # 2a: personal init
        "$ENV{HOME}/.bash_login",      # 2b: personal init
        "$ENV{HOME}/.profile",         # 2c: personal init
        #"$ENV{HOME}/bin/bash_profile", # 2d: Author's convention
        # INTERACTIVE NON-LOGIN:
        "/etc/bash.bashrc",            # system-wide init
        "$ENV{HOME}/.bashrc",          # personal init
        "$ENV{HOME}/bin/bash_profile", # I keep stuff here so not invisible.

    );
    ($verbose>1) && warn("Initial profile paths:\n    " . join("\n    ", @profilePaths) . "\n");

    # NON-INTERACTIVE (must be expanded; don't use $PATH)
    if (defined $ENV{BASH_ENV}) {
        ($verbose) && warn "Adding path: '$ENV{BASH_ENV}'\n";
        push @profilePaths, $ENV{BASH_ENV};
    }
    if (defined $ENV{ENV}) { # only if 'sh'
        push @profilePaths, $ENV{ENV};
    }
    if (@addProfile) {
        push @profilePaths, @addProfile;
    }
    return @profilePaths;
}


###############################################################################
# Functions to find specific definitions within a file (just use grep).
# (switching over to generic %functionRegexes)
#
my %functionRegexes = (
    "Python" =>     "^\\s*def\\s+\\w+\\s*\(",
    "Perl" =>       "^\\s*sub\\s+\\w+\\s*{",
    "BashFunct" =>  "^\\s*\\w+\(\)\\s*{",
    "Alias" =>      "^\\s*alias\\s+\\w+=",
);

sub findSomeDef {
    my ($cmd, $lg) = @_;
    my $regex = $functionRegexes{$lg};
    ($verbose) && print "Searching for definition in:\n";
    my @pairs = findAll($regex, \@allPaths, \@profilePaths);
    return @pairs;
}

sub findFunctionDef {  # Soon to be obsolete
    my ($cmd) = @_;
    my $regex = "^ *$cmd()\\s{";
    ($verbose) && print "Searching for shell function definition in:\n";
    my @pairs = findAll($regex, \@allPaths, \@profilePaths);
    return @pairs;
}

sub findAliasDef {  # Soon to be obsolete
    my ($cmd) = @_;
    my $regex = "^ *alias *$cmd=";
    ($verbose) && print "Searching for alias definition in:\n";
    my @pairs = findAll($regex, \@allPaths, \@profilePaths);
    return @pairs;
}

sub findAll {
    my ($regex, $allPathsRef, $profilePathsRef) = @_;
    for my $area ( ($allPathsRef, $profilePathsRef) ) {
        for my $path (@{$area}) {
            #($verbose) && print "    $path\n";
            my @pairs = getAllLines($path, $regex);
            if (scalar @pairs) { return(@pairs); }
        }
    }
    return(0); # not found
}

# Return array of lines matching the regex.
#
sub getAllLines {
    my ($file, $regex) = @_;
    (-r $file) || return("");
    ($verbose) && warn "getAllLines: grepping in '$file'.\n";
    my @pairs = ();
    my $buf = `grep -r -n '$regex' $file`;
    ($verbose) && warn "$file:\n    ++>$buf\n";
    if ($buf =~ m/^(\d+):/) {
        for my $line (split(/\n/, $buf)) {
            push @pairs, $line =~ s/(^[^:]*:[^:]*):.*/$1/;
        }
    }
    return(@pairs);
}

sub notFoundMsg {
    my ($cmdName, $type) = @_;
    reportType($cmdName, $type, sprintf(
        ", not found in any of %d profiles, %d other files (see \$ECMD_PATH).",
        scalar @profilePaths, scalar @allPaths));
}


###############################################################################
# Main
#
my $cmd = $ARGV[0];
my $fndLine = 1;

# Warn about environment issues
#
my $shell = $ENV{SHELL} || "";
($shell ne "/bin/zsh" && $verbose) && print
    "Your shell is $ENV{SHELL}, not /bin/zsh. This may not work....\n";

setupPaths();

# This only sets $path for *commmands* (not alias, builtin, shell fn, etc)
my ($typ, $path) = findType($login, $interactive, $cmd);

# Check for alias/shell function first, in case they overrode a name.
#
if ($typ eq "function") {
    #($path, $fndLine) = findSomeDef($cmd, "BashFunc");
    ($path, $fndLine) = findFunctionDef($cmd);
    if ($fndLine) {
        reportType($cmd, "function", $path);
    }
    else {
        notFoundMsg($cmd, "function");
    }
}
elsif ($typ eq "alias") {
    #($path, $fndLine) = findSomeDef($cmd, "Alias");
    ($path, $fndLine) = findAliasDef($cmd);
    if (defined $fndLine && $fndLine>0) {
        reportType($cmd, "alias", $path, $fndLine);
    }
    else {
        notFoundMsg($cmd, "alias");
    }
}
elsif ($typ eq "binary") {
    reportType($cmd, "binary", $path);
}
elsif ($typ eq "builtin") {
    reportType($cmd, "builtin", $path);
}
elsif ($typ eq "command") {
    reportType($cmd, "non-binary command", $path);
}
elsif ($typ eq "function") {
    reportType($cmd, "function", $path);
}
elsif ($typ eq "hashed") {
    reportType($cmd, "hashed", $path);
}
elsif ($typ eq "none") {
    # Could still be alias/shell function that script doesn't see?
    #
    my ($path1, $fndLine1) = findAliasDef($cmd);
    my ($path2, $fndLine2) = findFunctionDef($cmd);
    if ($fndLine1) {
        reportType($cmd, "alias", $path1);
        $path = $path1;
        $fndLine = $fndLine1;
    }
    elsif ($fndLine2) {
        reportType($cmd, "function", $path2);
        $path = $path2;
        $fndLine = $fndLine2;
    }
    else {
        reportType($cmd, "??? (not found)");
    }
}
elsif ($typ eq "reserved") {
    reportType($cmd, "reserved shell keyword", "(nothing to edit)");
}
else {
    ($quiet) || warn "Unrecognized response from '$cmd':\n$typ\n";
}

#warn "Item definition found at '$path'\n";

# If we found it, go edit it.
#
if ($path && $typ ne "binary" && $edit) {
    ($quiet) || printf("  Last modified %3.1f days ago.\n", -M($path));
    if (defined $ENV{EDITOR}) {
        my $edcmd = "$ENV{EDITOR} " . lineSeekOption($fndLine) . " $path";
        ($verbose) && warn "Editing with command: $edcmd\n";
        system($edcmd) && warn("Failed.\n");
    }
    else {
        warn "Environment variable \$EDITOR is not set. But file is at:\n    $path\n";
    }
}
